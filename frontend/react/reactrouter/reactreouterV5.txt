ğŸ”¹ React Router v5 (2019)

Fue la versiÃ³n mÃ¡s usada durante aÃ±os.
QuÃ© mejorÃ³
<Switch> para renderizar solo una ruta
API mÃ¡s estable
Ecosistema maduro
Ejemplo clÃ¡sico:

<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/users/:id" component={User} />
</Switch>


Problemas fundamentales
1. Orden importa (no determinista)
<Route path="/users/:id" />
<Route path="/users/new" />


2. Matching imperativo
El router evaluaba rutas en tiempo de render, no antes.
Consecuencia:
LÃ³gica de permisos dentro del componente
Redirects en useEffect
Carga de datos despuÃ©s del render


3. Data fetching desordenado
PatrÃ³n comÃºn:

useEffect(() => {
  fetchData()
}, [params.id])


âŒ Problemas:
Pantallas vacÃ­as
Loading states manuales
Race conditions
DifÃ­cil SSR

4. Abuso de HOCs y hooks
withRouter
useHistory
useLocation
â¡ï¸ Mucha lÃ³gica de navegaciÃ³n acoplada a componentes.











3ï¸âƒ£ FilosofÃ­a declarativa del routing moderno
ğŸ§  Cambio de mentalidad clave

Antes:

â€œRenderiza este componente y luego vemos quÃ© hacerâ€

Ahora:

â€œDescribe todo el Ã¡rbol de navegaciÃ³n y deja que el router decidaâ€



Declarativo significa:

Las rutas se definen como configuraciÃ³n
El router puede analizar todo antes del render
Menos lÃ³gica en componentes
MÃ¡s predecible, mÃ¡s testeable

Ejemplo mental:
Route = {
  path,
  loader,
  element,
  children
}


â¡ï¸ La ruta no solo renderiza UI, tambiÃ©n:
Carga datos
Maneja errores
Decide redirects
Define permisos