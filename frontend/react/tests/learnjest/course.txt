curso para parender a hacer tests con jest 
Mini-curso de Vitest
Testing moderno para Vite / ESM / React
ğŸ§  Â¿QuÃ© es Vitest?

Vitest es un test runner moderno creado por el equipo de Vite.
EstÃ¡ diseÃ±ado para:

ESM nativo

Velocidad extrema

Integrarse directamente con Vite

Reemplazar Jest en proyectos modernos

ğŸ‘‰ Vitest = Jest API + Vite engine

ğŸ§© Arquitectura interna de Vitest
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Test Files         â”‚
â”‚  *.test.ts / *.spec.ts    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Vitest Core        â”‚
â”‚  - Test collector        â”‚
â”‚  - Test scheduler        â”‚
â”‚  - Snapshot engine       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Vite Engine        â”‚
â”‚  - ESM loader             â”‚
â”‚  - HMR-based isolation    â”‚
â”‚  - Fast dependency graph  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Worker Threads       â”‚
â”‚  - Parallel execution     â”‚
â”‚  - Isolated contexts      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš™ï¸ Â¿CÃ³mo ejecuta Vitest un test?

Vite analiza el grafo de dependencias

Vitest detecta archivos de test

Cada test se ejecuta en un worker aislado

Usa ESM real, no transpila como Jest

Cachea mÃ³dulos (ultra rÃ¡pido)

Reporta resultados

ğŸ‘‰ Por eso Vitest es 5-10x mÃ¡s rÃ¡pido que Jest

ğŸ§ª API bÃ¡sica (muy similar a Jest)
import { describe, it, expect, vi } from 'vitest'

describe('sum', () => {
  it('adds numbers', () => {
    expect(1 + 2).toBe(3)
  })
})

ğŸ­ Mocking interno (vi)

Vitest usa ESM mocking, no require-hacks.

vi.mock('./api', () => ({
  fetchUser: vi.fn(),
}))


Internamente:

Intercepta el import

Sustituye el mÃ³dulo en el graph de Vite

Mantiene el mock por worker

ğŸ§  Snapshots en Vitest
expect(component).toMatchSnapshot()


Internals:

Serializa el output

Guarda snapshots por archivo

Soporta inline snapshots

ğŸ§ª Testing UI (React)

Vitest NO renderiza UI
â†’ Se combina con Testing Library

import { render, screen } from '@testing-library/react'

ğŸš€ Ventajas clave

âœ” Ultra rÃ¡pido
âœ” Perfecto para Vite / React / TS
âœ” Jest-compatible
âœ” ESM nativo
âœ” Ideal para monorepos modernos

âŒ Limitaciones

Menos plugins legacy

No ideal para proyectos CJS antiguos

No recomendado para Node 10 / 12

ğŸ§ª Mini-curso de Jest
El clÃ¡sico, robusto y probado en producciÃ³n
ğŸ§  Â¿QuÃ© es Jest?

Jest es un test runner completo creado por Facebook.

DiseÃ±ado para:

Proyectos grandes

Compatibilidad mÃ¡xima

Node.js tradicional

Legacy + modern code

ğŸ§© Arquitectura interna de Jest
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Test Files         â”‚
â”‚  *.test.js / *.spec.ts    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Jest Runtime       â”‚
â”‚  - Module loader          â”‚
â”‚  - Fake timers            â”‚
â”‚  - Mock system            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Babel / TS         â”‚
â”‚  - Transpilation layer    â”‚
â”‚  - CommonJS wrapping      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Worker Processes     â”‚
â”‚  - Child processes        â”‚
â”‚  - VM contexts            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš™ï¸ Â¿CÃ³mo ejecuta Jest un test?

Busca archivos de test

Transpila cÃ³digo (Babel / ts-jest)

Envuelve mÃ³dulos en CommonJS

Ejecuta en procesos hijos

Limpia mocks automÃ¡ticamente

ğŸ‘‰ MÃ¡s seguro, pero mÃ¡s lento

ğŸ§ª API bÃ¡sica
describe('sum', () => {
  test('adds numbers', () => {
    expect(1 + 2).toBe(3)
  })
})

ğŸ­ Mocking en Jest (jest.mock)
jest.mock('./api', () => ({
  fetchUser: jest.fn(),
}))


Internals:

Intercepta require

Reemplaza el mÃ³dulo

Mantiene un registro global de mocks

â± Fake Timers (internals)
jest.useFakeTimers()


Internamente:

Reemplaza setTimeout, setInterval

Controla el event loop virtual

Muy potente para async complejo

ğŸ§  Snapshots
expect(tree).toMatchSnapshot()


Jest fue el pionero en snapshots

ğŸš€ Ventajas clave

âœ” Extremadamente estable
âœ” Gran ecosistema
âœ” Ideal para Node, backend, legacy
âœ” Excelente control del runtime

âŒ Desventajas

Lento en proyectos grandes

ConfiguraciÃ³n compleja

ESM aÃºn problemÃ¡tico

No aprovecha Vite

âš”ï¸ Vitest vs Jest (Resumen rÃ¡pido)
CaracterÃ­stica	Vitest	Jest
Velocidad	âš¡âš¡âš¡âš¡âš¡	âš¡âš¡
ESM nativo	âœ…	âš ï¸
Vite integration	âœ…	âŒ
Legacy support	âŒ	âœ…
ConfiguraciÃ³n	Simple	Compleja
Mocking	vi	jest
ğŸ¯ RecomendaciÃ³n para TI

Con tu stack actual:

Frontend React / Vite â†’ Vitest

Backend Node / Legacy / CI crÃ­tico â†’ Jest

Monorepo moderno â†’ Vitest

SDKs / librerÃ­as pÃºblicas â†’ Jest