curso para parender a hacer tests con react testing library

Contrasta las difenrecias tecnicas /internals de react tesitng library y jest


Aunque no se vea en las dependecias al ir a node_modules se pude ver jest al isntalar t
testing library/jest-dom 
testing library/react.



Los test puedne ser ejecutados automaticmanete si estan dentro d eun folder llamado test o __tests__ o si bien tienen extension .test.js o  .test.ts / .test.tsx / .test.jsx 



Para poder probar interacciones con el uuario es neceairo isntalar:  
npm install --save-dev @testing-library/user-event






ğŸ§ª Curso breve â€” React Testing Library (RTL)
ğŸ¯ Objetivo del curso

Comprender:

QuÃ© problema resuelve RTL

Su filosofÃ­a

CÃ³mo funciona internamente

CÃ³mo interactÃºa con React, el DOM y el test runner (Vitest/Jest)

Por quÃ© no testea implementaciÃ³n, sino comportamiento

ğŸ§  1. Â¿QuÃ© es React Testing Library?

React Testing Library es una capa de utilidades construida sobre:

DOM Testing Library
        â†“
React Testing Library
        â†“
Vitest / Jest


ğŸ‘‰ RTL NO es un test runner
ğŸ‘‰ RTL NO es un assertion library

Su propÃ³sito es:

Probar tu aplicaciÃ³n como lo harÃ­a un usuario real

ğŸ§­ 2. FilosofÃ­a central (la clave de todo)

RTL se basa en un principio muy fuerte:

â The more your tests resemble the way your software is used, the more confidence they can give you â

âŒ Lo que NO promueve

Acceder a props internas

Llamar mÃ©todos privados

Buscar componentes por nombre

Mockear React internals

âœ… Lo que SÃ promueve

Buscar elementos por:

Texto visible

Roles accesibles

Labels

Simular eventos reales

Validar resultados visibles

ğŸ§© 3. Arquitectura interna de RTL
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Test Runner (Vitest / Jest) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ React Testing Library       â”‚
â”‚  - render()                 â”‚
â”‚  - screen                   â”‚
â”‚  - fireEvent / userEvent    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DOM Testing Library         â”‚
â”‚  - getByRole                â”‚
â”‚  - getByLabelText           â”‚
â”‚  - queryByText              â”‚
â”‚  - findBy*                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ jsdom (DOM virtual)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš™ï¸ 4. Internals clave explicados
4.1 render()
render(<MyComponent />)


Internamente:

Crea un container DOM (div)

Monta el componente con ReactDOM.createRoot

Inserta el Ã¡rbol React en jsdom

Devuelve helpers (rerender, unmount, etc.)

ğŸ”‘ No monta en un navegador real
ğŸ”‘ Usa jsdom (DOM simulado)

4.2 screen
screen.getByRole('button', { name: /login/i })


Internamente:

Es un wrapper global sobre el document.body

Evita que dependas del container

Fuerza mejores prÃ¡cticas (tests mÃ¡s realistas)

4.3 Queries (el corazÃ³n de RTL)
Tipos de queries (orden recomendado):
Tipo	Comportamiento
getBy*	Falla si no existe
queryBy*	Retorna null
findBy*	Async (Promise)

Ejemplo interno:

findByRole â†’ waitFor â†’ getByRole

4.4 Accesibilidad como base

RTL usa el Accessibility Tree, no solo el DOM:

role="button"

aria-label

<label for="">

Ejemplo:

getByRole('textbox', { name: /email/i })


Internamente:

Resuelve el nombre accesible

Combina:

label

aria-label

texto visible

required indicators (*)

ğŸ‘‰ Por eso los tests fallan cuando cambia el wrapper/label (como te pasÃ³)

â±ï¸ 5. Async internals (waitFor, findBy)
await waitFor(() => {
  expect(screen.getByText('Success')).toBeInTheDocument()
})


Internamente:

Reintenta el callback

Usa un loop con timeout (default ~1000ms)

Captura errores hasta que:

Pase

Timeout expire

Esto permite testear:

Effects

Requests mockeados

Cambios de estado

ğŸ–±ï¸ 6. Eventos: fireEvent vs userEvent
fireEvent

Bajo nivel

Dispara eventos individuales

userEvent

Alto nivel (recomendado)

Simula comportamiento humano

await user.type(input, 'hello')


Internamente:

keyDown â†’ input â†’ keyUp

respeta delays

activa validaciones reales

ğŸ§ª 7. RelaciÃ³n con Vitest / Jest

RTL:

Renderiza

InteractÃºa

Consulta DOM

Vitest/Jest:

Ejecuta tests

Hace assertions

Maneja mocks y spies

expect(screen.getByText('Login')).toBeInTheDocument()


ğŸ‘‰ RTL no sabe quÃ© es expect

ğŸš¨ 8. Errores comunes (y por quÃ© pasan)
âŒ Test frÃ¡gil
getByTestId('input')

âœ… Test robusto
getByRole('textbox', { name: /email/i })


RazÃ³n:

RTL estÃ¡ diseÃ±ado para romper tests cuando el UX cambia

ğŸ§  9. Regla de oro mental

Si un usuario no puede verlo o usarlo, no deberÃ­as testearlo

ğŸ“š 10. Checklist profesional RTL

âœ” Usa getByRole primero
âœ” Prefiere userEvent
âœ” Evita testId salvo Ãºltimo recurso
âœ” Testea flujos, no funciones
âœ” Deja que los tests fallen cuando cambia el UI

ğŸš€ Siguiente nivel (opcional)

Si quieres, puedo:

Explicar cÃ³mo RTL se integra con React Fiber

Mostrar cÃ³mo se resuelven labels accesibles paso a paso

Comparar RTL vs Enzyme internamente

Crear un cheat sheet RTL + Vitest