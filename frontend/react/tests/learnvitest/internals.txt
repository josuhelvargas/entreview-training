1ï¸âƒ£ El problema que Vitest vino a resolver

Antes de Vitest:

Jest

Trae su propio bundler

Transforma cÃ³digo con Babel / ts-jest

No conoce Vite

Duplica configuraciÃ³n

Tests lentos en proyectos grandes

Con Vite:

Ya tienes ESM

Ya tienes transformaciÃ³n ultra rÃ¡pida

Ya tienes dependency graph

Pero Jest no usa nada de eso

ğŸ‘‰ Vitest nace para reutilizar Vite en lugar de competir con Ã©l

2ï¸âƒ£ Arquitectura mental de Vitest (visiÃ³n de alto nivel)

Piensa en Vitest como:

Vitest
 â”œâ”€â”€ Usa Vite como motor de build
 â”œâ”€â”€ Ejecuta tests en Node o Browser-like env
 â”œâ”€â”€ Corre mÃ³dulos ESM nativos
 â”œâ”€â”€ Usa la misma config que tu app
 â””â”€â”€ Expone una API compatible con Jest


Vitest NO es un bundler
ğŸ‘‰ Vite es el bundler
ğŸ‘‰ Vitest es un orquestador de tests encima de Vite

3ï¸âƒ£ QuÃ© ocurre cuando ejecutas vitest
Paso 1 â€“ Arranque del Vite Dev Server (interno)

Vitest levanta Vite en modo interno, no para servir HTML, sino para:

Resolver imports

Transformar TS / JSX / TSX

Aplicar plugins (React, aliases, env, etc.)

Esto significa:

âŒ No hay Babel separado

âŒ No hay ts-jest

âœ… Todo pasa por el mismo pipeline que tu app

Paso 2 â€“ ResoluciÃ³n de mÃ³dulos (ESM real)

Vitest usa:

ES Modules nativos

Grafo de dependencias de Vite

Esto permite:

Importaciones rÃ¡pidas

Hot reload de tests

Cache de mÃ³dulos ya transformados

ğŸ’¡ AquÃ­ estÃ¡ una de las grandes diferencias con Jest.

Paso 3 â€“ TransformaciÃ³n de cÃ³digo

Cuando un test importa algo como:

import { Button } from './Button';


Vitest:

Le pide a Vite que transforme el archivo

Vite aplica:

TypeScript

JSX / React plugin

Alias

Env vars

El resultado es JS ejecutable inmediato

ğŸ‘‰ No hay paso intermedio extra

4ï¸âƒ£ CÃ³mo Vitest ejecuta los tests internamente

Vitest crea un test runner propio, inspirado en Jest pero mÃ¡s simple:

Internals del runner:

Carga archivos de test

Registra bloques describe, it, test

Ejecuta tests en orden

Captura errores

Reporta resultados

Algo asÃ­ internamente:

TestCollector
 â”œâ”€â”€ describe blocks
 â”‚   â”œâ”€â”€ it/test cases
 â”‚   â””â”€â”€ hooks (beforeEach, afterEach)
 â”œâ”€â”€ Assertion tracking
 â””â”€â”€ Result reporter

5ï¸âƒ£ Sistema de assertions (expect)

Vitest no reimplementÃ³ todo desde cero.

Internamente:

Usa @vitest/expect

Basado en expect de Jest

Mismos matchers:

toBe

toEqual

toHaveBeenCalledWith

etc.

ğŸ‘‰ Esto es 100% intencional:

Migrar de Jest â†’ Vitest es trivial

Menos curva de aprendizaje

6ï¸âƒ£ Sistema de mocks: cÃ³mo funciona realmente
6.1 vi.fn() (equivalente a jest.fn())

Internamente:

FunciÃ³n envuelta

Contador de llamadas

Registro de argumentos

Control de implementaciÃ³n

const mock = vi.fn().mockReturnValue(42);


Internals:

MockFunction
 â”œâ”€â”€ calls[]
 â”œâ”€â”€ results[]
 â”œâ”€â”€ implementation
 â””â”€â”€ reset / restore

6.2 vi.mock() (mock de mÃ³dulos)

AquÃ­ Vitest se apoya muchÃ­simo en Vite.

Cuando haces:

vi.mock('./api');


Vitest:

Intercepta la resoluciÃ³n del mÃ³dulo

Le dice a Vite:
â€œCuando alguien importe este mÃ³dulo â†’ usa esta implementaciÃ³nâ€

Vite actualiza el grafo

ğŸ’¡ Esto es mÃ¡s limpio que Jest, porque:

No parchea require

No usa hacks de CommonJS

Todo es ESM-first

7ï¸âƒ£ Entornos de ejecuciÃ³n (Node vs Browser-like)

Vitest soporta:

Node environment

Default

RÃ¡pido

Ideal para lÃ³gica pura

jsdom / happy-dom

Simula DOM

Necesario para React

test: {
  environment: 'jsdom'
}


Internamente:

Carga un DOM virtual

Inyecta window, document, navigator

React cree que estÃ¡ en un browser

8ï¸âƒ£ RelaciÃ³n exacta con React

Vitest no conoce React directamente.

React entra por:

Plugin de Vite (@vitejs/plugin-react)

React Testing Library (RTL)

Flujo real:

Vitest
 â””â”€â”€ Vite
      â””â”€â”€ React plugin
           â””â”€â”€ JSX â†’ JS
                â””â”€â”€ RTL render()


Vitest solo:

Ejecuta

Aserta

Mockea

ğŸ‘‰ Renderizar es responsabilidad de RTL, no de Vitest

9ï¸âƒ£ ComparaciÃ³n profunda: Vitest vs Jest (internals)
Aspecto	Jest	Vitest
Sistema de mÃ³dulos	CommonJS + ESM hÃ­brido	ESM nativo
TransformaciÃ³n	Babel / ts-jest	Vite
Velocidad	Media	Muy alta
Cache	Propia	Cache de Vite
Config	Separada	Compartida con app
Hot reload	Limitado	Nativo
Mocks	require hijacking	Module graph

ğŸ‘‰ Jest es autosuficiente
ğŸ‘‰ Vitest es integrado

ğŸ”Ÿ Regla mental para recordar Vitest

Vitest no reemplaza Vite
Vitest se monta sobre Vite

O dicho de otra forma:

Vitest = Jest-like API + Vite engine

1ï¸âƒ£1ï¸âƒ£ Â¿CuÃ¡ndo usar Vitest vs Jest?
Usa Vitest si:

Usas Vite

Usas React moderno

Quieres tests rÃ¡pidos

Quieres menos config

Usa Jest si:

Proyecto legacy

Webpack

Node puro sin Vite

Ecosistema muy especÃ­fico de Jest

ğŸ§  Modelo mental final (memorÃ­zalo)
Jest:
  [Test Runner] + [Transformer] + [Module System]

Vitest:
  [Test Runner]
        |
        v
     [Vite]
        |
        v
   [Your App Config]