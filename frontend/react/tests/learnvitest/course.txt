ğŸŸ¦ MÃ“DULO 1 â€” Â¿QuÃ© es Vitest y por quÃ© existe?
Â¿QuÃ© es Vitest?

Vitest es un test runner moderno diseÃ±ado para:

Proyectos Vite

Ecosistema ESM

TypeScript nativo

Tests rÃ¡pidos con Hot Reload

ğŸ‘‰ Es el equivalente moderno de Jest, pero optimizado para Vite.

Â¿Por quÃ© no Jest?
Problema en Jest	SoluciÃ³n en Vitest
Config lenta	Usa Vite internamente
ESM complicado	ESM-first
Mocks verbosos	vi simple
TS lento	TS nativo
No HMR	HMR en tests
ğŸŸ¦ MÃ“DULO 2 â€” Arquitectura interna de Vitest (importante)
ğŸ§  Internals simplificados
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ vitest run   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vite Dev Server (Node)   â”‚
â”‚  - Transpila TS/JSX     â”‚
â”‚  - Resuelve imports     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Test Runtime             â”‚
â”‚  - vi (mocks, spies)     â”‚
â”‚  - expect (assertions)   â”‚
â”‚  - describe / it         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Worker Threads           â”‚
â”‚  - tests en paralelo     â”‚
â”‚  - aislamiento           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”‘ Idea clave

Vitest NO transpila solo
ğŸ‘‰ Usa Vite como motor
Por eso:

Resuelve alias igual que tu app

Usa el mismo tsconfig

Respeta vite.config.ts

ğŸŸ¦ MÃ“DULO 3 â€” API bÃ¡sica (lo que usas todos los dÃ­as)
Estructura bÃ¡sica
import { describe, it, expect } from 'vitest';

describe('My feature', () => {
  it('works', () => {
    expect(1 + 1).toBe(2);
  });
});

Assertions (expect)
expect(value).toBe(1);
expect(value).toEqual({ a: 1 });
expect(value).toBeTruthy();
expect(value).toBeDefined();
expect(fn).toHaveBeenCalled();

ğŸŸ¦ MÃ“DULO 4 â€” Mocks (la parte mÃ¡s crÃ­tica)
vi.fn() â†’ funciones falsas
const fn = vi.fn();
fn('a');

expect(fn).toHaveBeenCalledWith('a');

vi.spyOn() â†’ espiar funciones reales
vi.spyOn(console, 'error').mockImplementation(() => {});

vi.mock() â†’ mock de mÃ³dulos (MUY IMPORTANTE)
vi.mock('@frx/frx-react-context', () => ({
  useLogin: vi.fn(),
}));


ğŸ‘‰ Se ejecuta ANTES del import real
ğŸ‘‰ Hoisted automÃ¡ticamente

ğŸŸ¦ MÃ“DULO 5 â€” Internals de vi.mock (esto explica muchos bugs)
CÃ³mo funciona realmente

Vitest intercepta imports

Registra el mock

Cuando el mÃ³dulo se importa â†’ devuelve el mock

â— Por eso:

vi.mock debe estar top-level

No dentro de describe

No dentro de it

ğŸŸ¦ MÃ“DULO 6 â€” Testing React (con RTL)

Vitest NO renderiza React
ğŸ‘‰ Usa @testing-library/react

Render bÃ¡sico
render(<MyComponent />);

Buscar elementos (prioridad correcta)

getByRole âœ…

getByLabelText

getByText

getByTestId (Ãºltimo recurso)

Ejemplo real (como tus tests):

screen.getByRole('textbox', { name: /email/i });

ğŸŸ¦ MÃ“DULO 7 â€” Accesibilidad y por quÃ© fallaban tus tests
Por quÃ© esto fallÃ³:
getByRole('textbox', { name: /^state/i })


Pero el DOM tenÃ­a:

Name "* State:"

SoluciÃ³n correcta:
getByRole('textbox', { name: /state/i })


ğŸ‘‰ RTL usa el accessible name, no el texto visible plano
Incluye:

*

:

aria-required

ğŸŸ¦ MÃ“DULO 8 â€” Hooks, Context y Router (caso real tuyo)
Mockear hooks
vi.mock('hooks/useEventConfiguration', () => ({
  useEventConfiguration: () => ({
    nextStep: vi.fn(),
  }),
}));

Router (TanStack)

Vitest NO maneja routing

TÃº creas router de test

Injectas contexto

âœ”ï¸ Lo estÃ¡s haciendo perfecto con:

createRootRouteWithContext
createRouter
RouterProvider

ğŸŸ¦ MÃ“DULO 9 â€” EjecuciÃ³n de tests
Un solo archivo
npx vitest run src/components/Personal/PersonalFormField.test.tsx

Watch mode
npx vitest

Con reporter verbose
npx vitest run --reporter=verbose

ğŸŸ¦ MÃ“DULO 10 â€” Debugging profesional de tests
Ver DOM real
screen.debug();

Ver roles disponibles
import { logRoles } from '@testing-library/dom';
logRoles(screen.getByTestId('root'));

Tip clave

Si un test falla:

Lee el DOM que imprime RTL

Ajusta el selector, NO el componente

Evita asserts frÃ¡giles