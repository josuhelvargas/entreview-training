CURSO: GestiÃ³n de Estado en React con Redux Toolkit y Zustand
ğŸŸ¦ MÃ“DULO 0 â€” Fundamentos (obligatorio)
0.1 Â¿QuÃ© es el estado en React?

Estado local (useState)

Estado derivado

Estado compartido

Estado de servidor vs estado de UI

0.2 Problemas comunes sin una librerÃ­a

Prop drilling

LÃ³gica duplicada

useEffect desordenados

Estados inconsistentes

ğŸŸ¦ MÃ“DULO 1 â€” Redux moderno (Redux Toolkit)
1.1 Â¿QuÃ© es Redux hoy?

Redux clÃ¡sico vs Redux Toolkit

Principios:

Single source of truth

Inmutabilidad

Reducers puros

1.2 Redux Toolkit (RTK)

Â¿Por quÃ© existe RTK?

QuÃ© problemas resuelve:

Boilerplate

Verbosidad

Mutaciones complejas

ğŸŸ¦ MÃ“DULO 2 â€” Store y arquitectura
2.1 configureStore()

QuÃ© hace

Middlewares incluidos

DevTools automÃ¡ticos

2.2 OrganizaciÃ³n de carpetas (feature-based)
src/
 â””â”€ features/
     â””â”€ inventory/
         â”œâ”€ inventorySlice.ts
         â”œâ”€ inventorySelectors.ts
         â”œâ”€ inventoryApi.ts
         â””â”€ types.ts

2.3 Tipado correcto

RootState

AppDispatch

Por quÃ© importa

ğŸŸ¦ MÃ“DULO 3 â€” Slices (corazÃ³n de Redux Toolkit)
3.1 Â¿QuÃ© es un Slice?

Estado + reducers + acciones

FilosofÃ­a feature-first

3.2 createSlice()

name

initialState

reducers

MutaciÃ³n segura con Immer

3.3 Acciones generadas automÃ¡ticamente

QuÃ© se genera

CÃ³mo se exportan

Buenas prÃ¡cticas

ğŸŸ¦ MÃ“DULO 4 â€” Selectors (lectura del estado)
4.1 Â¿QuÃ© es un selector?

FunciÃ³n pura

Encapsula estructura del store

4.2 Selectors simples y derivados

selectItems

selectItemById

createSelector

4.3 Performance y re-render

MemoizaciÃ³n

Evitar renders innecesarios

ğŸŸ¦ MÃ“DULO 5 â€” Thunks (async tradicional)
5.1 Â¿QuÃ© es un thunk?

FunciÃ³n async que despacha acciones

Flujo async en Redux

5.2 createAsyncThunk()

pending / fulfilled / rejected

Manejo de errores

CancelaciÃ³n y abort controllers

5.3 Anti-patterns con thunks

Thunks gigantes

LÃ³gica de UI en thunks

ğŸŸ¦ MÃ“DULO 6 â€” RTK Query (estado de servidor)
6.1 Â¿QuÃ© problema resuelve RTK Query?

Fetching

Caching

DeduplicaciÃ³n

InvalidaciÃ³n automÃ¡tica

6.2 createApi()

baseQuery

endpoints

query vs mutation

6.3 Hooks generados

useGetItemsQuery

useCreateItemMutation

6.4 Cache y tags

providesTags

invalidatesTags

Re-fetch automÃ¡tico

6.5 Â¿Por quÃ© RTK Query elimina el 80% de los thunks?
ğŸŸ¦ MÃ“DULO 7 â€” UI State vs Server State
7.1 QuÃ© va en RTK Query

Datos remotos

Estado del backend

7.2 QuÃ© va en un Slice

Modales

Filtros

Drafts

PaginaciÃ³n

7.3 QuÃ© queda en useState

Inputs simples

Toggles locales

ğŸŸ¦ MÃ“DULO 8 â€” Zustand (estado ligero)
8.1 Â¿QuÃ© es Zustand?

Store sin reducers

Sin providers

Minimalista

8.2 Crear un store

create()

Estado + acciones

8.3 Selectores en Zustand

Re-render control

Shallow comparison

ğŸŸ¦ MÃ“DULO 9 â€” ComparaciÃ³n Redux Toolkit vs Zustand
Aspecto	Redux Toolkit	Zustand
Boilerplate	Medio	Muy bajo
Escalabilidad	Alta	Media
Server State	RTK Query	Manual
DevTools	Excelente	BÃ¡sico
Arquitectura	Formal	Flexible
Ideal para	Apps grandes	Apps medianas
ğŸŸ¦ MÃ“DULO 10 â€” Mismo CRUD con ambos enfoques
10.1 CRUD con Redux Toolkit + RTK Query

Tabla de inventario

Fetch

Create / Update / Delete

10.2 CRUD con Zustand

Fetch manual

Estado local

ComparaciÃ³n de cÃ³digo

ğŸŸ¦ MÃ“DULO 11 â€” Patrones avanzados

NormalizaciÃ³n (entityAdapter)

PaginaciÃ³n

Optimistic updates

Error boundaries

Testing de slices

Testing de RTK Query

ğŸŸ¦ MÃ“DULO 12 â€” CuÃ¡ndo usar cada uno (guÃ­a real)
Usa Redux Toolkit si:

App enterprise

Muchos devs

Backend complejo

Reglas claras

Usa Zustand si:

App pequeÃ±a/mediana

UI-heavy

Menos ceremony

ğŸ¯ PROYECTO FINAL

Sistema de Inventario

Tabla CRUD

Redux Toolkit + RTK Query

Zustand (versiÃ³n alternativa)

ComparaciÃ³n de cÃ³digo y decisiones