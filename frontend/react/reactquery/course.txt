üß© Visi√≥n general del curso

Objetivo general:
Que puedas estructurar tus apps as√≠:

El componente solo renderiza UI.

La l√≥gica de datos vive en hooks de React Query + hooks propios.

Puedes reutilizar esos hooks en otros proyectos (misma base de c√≥digo).

Estado de servidor ‚Üí React Query; estado local/UI ‚Üí useState/useReducer/Zustand/etc.

Propuesta: 6 m√≥dulos + proyecto final.

üîπ M√ìDULO 1 ‚Äì Conceptos base: server state vs client state

Objetivo: Entender por qu√© React Query existe y qu√© problema resuelve.

Tipos de estado en una app React

UI state: inputs, modal abierto/cerrado, tabs seleccionadas.

Server state: datos que vienen de una API (user, orders, products).

Diferencias clave:

El server state no lo controlas t√∫ (lo controla la API).

Puede cambiar en el servidor sin que el cliente lo sepa.

Necesita sincronizaci√≥n, cach√©, reintentos, invalidaci√≥n.

Problema de usar solo useState/useEffect

Mucho c√≥digo repetido: loading, error, fetch, try/catch.

Duplicaci√≥n de llamadas a la API en diferentes componentes.

Dificultad para compartir/centralizar cach√©.

useEffect gigantes y dif√≠ciles de testear.

Qu√© aporta React Query

Cach√© por query key.

Estados autom√°ticos: isLoading, isError, isSuccess, status.

Reintentos autom√°ticos.

Refetch on window focus (re-sincronizaci√≥n).

Invalidaci√≥n selectiva de cach√©.

üëâ Ejercicio:

Toma un componente que use useEffect + fetch.

Haz una lista de todo el ‚Äúruido‚Äù de estado que hay (loading, error, etc.).

Piensa c√≥mo se ver√≠a si solo tuvieras isLoading, data, error.

üîπ M√ìDULO 2 ‚Äì Fundamentos de React Query (useQuery / QueryClient)

Objetivo: Usar React Query correctamente en un proyecto real.

Instalaci√≥n y setup b√°sico

npm install @tanstack/react-query (v4+).

QueryClient y QueryClientProvider.

D√≥nde inicializarlo (por ejemplo en main.tsx / index.tsx).

Hook principal: useQuery

Firma b√°sica:

const { data, isLoading, isError, error } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId),
});


queryKey como identificador √∫nico de la data.

queryFn como funci√≥n que trae los datos (normalmente abstra√≠da en un servicio).

Estados que te da React Query

isLoading, isFetching, isError, isSuccess, status.

Patrones para UI:

if (isLoading) return <Spinner />

if (isError) return <ErrorMessage />

return <UserCard user={data} />

Opciones importantes

staleTime, cacheTime.

enabled para queries condicionales.

refetchOnWindowFocus, refetchInterval.

üëâ Ejercicio:

Implementa useQuery en un componente que muestre un usuario.

Cambia el staleTime para ver c√≥mo cambia el comportamiento al volver a la pesta√±a del navegador.

üîπ M√ìDULO 3 ‚Äì Custom Hooks de datos: el ‚Äúcerebro limpio‚Äù

Objetivo: Construir hooks tipo useUserInfo, useUserAddress, useOrders, etc., para mantener los componentes casi sin l√≥gica de datos.

Patr√≥n: ‚ÄúUI vs Data Hooks‚Äù

UI hooks: useModal, useStepper, useForm.

Data hooks: useUser, useOrders, useProducts.

Encapsular React Query en hooks propios
Ejemplo:

// services/userService.ts
export async function getUserInfo(userId: string) {
  const res = await fetch(`/api/users/${userId}`);
  if (!res.ok) throw new Error('Error fetching user');
  return res.json();
}

// hooks/useUserInfo.ts
import { useQuery } from '@tanstack/react-query';
import { getUserInfo } from '../services/userService';

export function useUserInfo(userId: string) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => getUserInfo(userId),
    staleTime: 1000 * 60, // 1 min
  });
}


Y en el componente:

function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, isError } = useUserInfo(userId);

  if (isLoading) return <p>Loading...</p>;
  if (isError || !user) return <p>Error</p>;

  const { userName, address } = user;

  return (
    <div>
      <h1>{userName}</h1>
      <p>{address}</p>
    </div>
  );
}


Ventaja para reutilizar en otros proyectos

Extraes /hooks y /services a una librer√≠a interna (otro repo o paquete npm privado).

Cualquier app que instale esa librer√≠a tiene ya:

useUserInfo

useUserOrders

useUserPermissions

Solo necesitan wirear el QueryClientProvider y la configuraci√≥n de base URL.

Organizaci√≥n por dominio

src/domain/user/hooks/useUserInfo.ts

src/domain/user/hooks/useUserAddress.ts

src/domain/orders/hooks/useOrders.ts

src/domain/orders/hooks/useOrderDetails.ts

üëâ Ejercicio:

Crea una carpeta /domain/user con:

userService.ts (funciones que llaman a la API).

useUserInfo.ts (hook de React Query).

Refactoriza 2 componentes para que usen useUserInfo.

üîπ M√ìDULO 4 ‚Äì Mutaciones, invalidaci√≥n e ‚Äúinmutabilidad limpia‚Äù

Objetivo: Manejar POST/PUT/DELETE sin ensuciar el estado global.

useMutation para operaciones de escritura

Crear usuario, actualizar direcci√≥n, eliminar orden.

Firma b√°sica:

const mutation = useMutation({
  mutationFn: updateUserAddress,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['user', userId] });
  },
});


Invalidaci√≥n de queries

Por key (invalidateQueries(['user', userId])).

Por prefijo (invalidar todas las de ['orders']).

Por filtros.

Actualizaci√≥n optimista (optimistic updates)

onMutate, onError, onSettled.

Patrones para probar cambios en UI sin esperar la API.

Ideal para UX r√°pida sin llenar componentes de l√≥gica de rollback.

Encapsular mutaciones en hooks

useUpdateUserAddress().

useCreateOrder().

useCancelOrder().

Ejemplo:

export function useUpdateUserAddress(userId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (newAddress: string) => updateUserAddress(userId, newAddress),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user', userId] });
    },
  });
}


üëâ Ejercicio:

Crea useUpdateUserAddress.

√ösalo en un formulario simple.

Al guardar, invalidar ['user', userId] para refrescar la info.

üîπ M√ìDULO 5 ‚Äì Dise√±o limpio de arquitectura con React Query

Objetivo: Integrar React Query en una arquitectura ‚Äúlimpia‚Äù y reutilizable.

Capas recomendadas

Capas t√≠picas:

/api o /services: llamadas HTTP, mapeo de DTOs.

/domain/*/hooks: hooks de React Query por contexto de negocio.

/components: puros componentes de UI (sin fetch).

SI quieres reutilizar entre apps:

Mover /services + /domain/*/hooks a una librer√≠a compartida.

Convenciones de nombres

Queries: useXxxQuery o useXxx.

Mutaciones: useXxxMutation o useXxxAction.

Query keys: constantes tipo USER_QUERY_KEYS = { detail: (id) => ['user', id] }.

Separar server state de client/UI state

React Query: datos que vienen de API.

Otro store (Zustand, Redux, contextos) para cosas como:

Tema oscuro/claro.

Estado del wizard/pasos.

Filtros UI que no dependen de API.

SSR / SSG (opcional si usas Next.js)

dehydratedState, Hydrate.

Prefetch de queries en el servidor.

Mantener el patr√≥n de hooks alineado con SSR.

üëâ Ejercicio:

Reorganiza tu proyecto actual:

Crea /services y /domain.

Mueve hooks de React Query a /domain.

Actualiza imports para que los componentes solo consuman los hooks.

üîπ M√ìDULO 6 ‚Äì Buenas pr√°cticas, testing y patrones avanzados

Objetivo: Hacerlo ‚Äúproduction ready‚Äù.

Configuraci√≥n global del QueryClient

Valores por defecto para retry, staleTime, refetchOnWindowFocus.

Definir una pol√≠tica clara por tipo de datos:

Datos casi est√°ticos ‚Üí staleTime alto.

Datos cr√≠ticos ‚Üí revalidaci√≥n frecuente.

Manejo de errores global

onError a nivel de QueryClient.

Mostrar toasts, modales, logs.

Integraci√≥n con Sentry u otra herramienta.

Paginated e infinite queries

useInfiniteQuery para listas grandes.

Patrones de ‚Äúcargar m√°s‚Äù e infinite scroll.

Testing

Testear hooks con React Testing Library + QueryClientProvider de prueba.

Mockear fetch / Axios.

Testear componentes que consumen hooks sin tocar la API real.

üëâ Ejercicio:

Configura un QueryClient de pruebas.

Escribe un test para useUserInfo que verifique:

Que llama a la API.

Que devuelve la data esperada.

Que maneja error.

üèÅ Proyecto final del curso

Objetivo: Armar una mini ‚Äúlibrer√≠a de hooks de datos‚Äù reutilizable.

Requerimientos

Crea un proyecto (o monorepo) con:

apps/web ‚Üí una app React sencilla.

packages/data-hooks ‚Üí paquete con:

/services

/domain/user/hooks

/domain/orders/hooks

En packages/data-hooks expone hooks como:

useUserInfo(userId)

useUserOrders(userId)

useOrderDetails(orderId)

En apps/web:

Usa el QueryClientProvider.

Crea p√°ginas que consumen esos hooks sin saber c√≥mo se hace el fetch.

Bonus:

Publica el paquete en un registry privado (GitHub Packages o similar).