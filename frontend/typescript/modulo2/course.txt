
interface User {
  id: number;
  name: string;
}

// Extender interfaces
interface AdminUser extends User {
  role: "admin";
}



ğŸ”¹ Formas de declarar funciones
// DeclaraciÃ³n tradicional
function sum(a: number, b: number): number {
  return a + b;
}

// FunciÃ³n como expresiÃ³n
const sum2 = (a: number, b: number): number => a + b;

// Type alias de funciÃ³n
type BinaryFn = (a: number, b: number) => number;

const multiply: BinaryFn = (a, b) => a * b;

ğŸ”¹ Overloads (sobrecarga)

Permiten describir mÃºltiples firmas para una misma funciÃ³n:

function parseInput(input: string): string[];
function parseInput(input: number): number[];
function parseInput(input: string | number): (string | number)[] {
  if (typeof input === "string") {
    return input.split(",");
  }
  return [input];
}

const a = parseInput("a,b,c"); // string[]
const b = parseInput(10);      // number[]


Las firmas â€œexpuestasâ€ se ponen arriba, y la implementaciÃ³n abajo.

ğŸ”¹ this en funciones

En TS puedes tipar this en funciones normales (no en arrow functions):

interface Logger {
  prefix: string;
  log(this: Logger, msg: string): void;
}

const logger: Logger = {
  prefix: "[APP]",
  log(msg) {
    console.log(this.prefix, msg); // `this` es Logger
  },
};

ğŸ”¹ Tipar un try/catch correctamente
async function fetchJson(url: string): Promise<unknown> {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`HTTP ${res.status}`);
  }
  return res.json();
}

async function safeCall() {
  try {
    const data = await fetchJson("/api/participants");
    // aquÃ­ puedes validar `data` antes de usarlo
  } catch (err: unknown) {
    if (err instanceof Error) {
      console.error("Error:", err.message);
    } else {
      console.error("Unknown error:", err);
    }
  }
}

ğŸ”¹ MÃ©todos estÃ¡ticos
class MathUtils {
  static sum(a: number, b: number) {
    return a + b;
  }
}

MathUtils.sum(1, 2);

ğŸ”¹ Herencia y clases abstractas
abstract class Shape {
  constructor(public color: string) {}
  abstract area(): number; // debe implementarse en las hijas
}

class Rectangle extends Shape {
  constructor(color: string, public width: number, public height: number) {
    super(color);
  }

  area(): number {
    return this.width * this.height;
  }
} 



Formas de declarar funciones
// DeclaraciÃ³n tradicional
function sum(a: number, b: number): number {
  return a + b;
}

// FunciÃ³n como expresiÃ³n
const sum2 = (a: number, b: number): number => a + b;

// Type alias de funciÃ³n
type BinaryFn = (a: number, b: number) => number;

const multiply: BinaryFn = (a, b) => a * b;
ğŸ”¹ Enum numÃ©rico
enum Role {
  Admin,      // 0
  Editor,     // 1
  Viewer,     // 2
}

const r: Role = Role.Admin;

Internamente se compila a un objeto con mapeo numÃ©rico y reverso.

ğŸ”¹ Enum string
enum Status {
  Active = "ACTIVE",
  Inactive = "INACTIVE",
  Pending = "PENDING",
}




ğŸ”¹ Literal types
type ResultStatus = "success" | "error";

function handleResult(status: ResultStatus) {
  if (status === "success") {
    // TS sabe que status es exactamente "success"
  } else {
    // aquÃ­ status es "error"
  }
} 


ğŸ”¹ Namespaces (por quÃ© evitarlos)

Antiguo patrÃ³n TS para agrupar cosas:

namespace MyLib {
  export function foo() {}
}


Hoy no se recomienda en aplicaciones modernas porque:

Rompe el modelo de mÃ³dulos nativos de ES.

El estÃ¡ndar es usar ESModules (import/export).

Se siguen usando a veces en definiciones .d.ts antiguas, pero para cÃ³digo nuevo â†’ usa mÃ³dulos normales.



âœ… Ventaja principal: unknown obliga a validar antes de usar; any no.
Tipo	Permite usar el valor sin validar	Obliga a comprobar el tipo antes de usar	Â¿Seguridad de tipos?
any	âœ”ï¸ SÃ­	âŒ No	âŒ Baja
unknown	âŒ No	âœ”ï¸ SÃ­	âœ”ï¸ Alta

Contexto profesional
Use unknown cuando:

No conoces el tipo de un valor externo:

JSON.parse

Respuestas de APIs externas

catch(err)

mensajes de websockets

cualquier entrada no confiable

Use any solo cuando:

EstÃ¡s migrando cÃ³digo viejo.

EstÃ¡s prototipando algo rÃ¡pido temporalmente.

EstÃ¡s interactuando con una librerÃ­a que TS no tipa correctamente.