ğŸŸ¦ 1. Nullish Coalescing (??)
â“ Â¿QuÃ© hace?

Devuelve el lado derecho SOLO si el valor del lado izquierdo es:

null

undefined

Es decir:
Solo coalesce valores "ausentes", no valores falsy.

âœ”ï¸ Ejemplo
const x = null ?? "default";  // "default"
const y = undefined ?? 10;    // 10

const z = 0 ?? 50;            // 0 (NO usa el default)
const w = "" ?? "hola";       // "" (NO usa el default)

âœ”ï¸ Caso de uso real

Evitar que valores vÃ¡lidos como 0, "", false sean reemplazados:

const count = userInput ?? 0;

ğŸŸ© 2. Optional Chaining (?.)
â“ Â¿QuÃ© hace?

Permite acceder a propiedades sin causar error si alguna es null o undefined.

âœ”ï¸ Ejemplo
const user = { profile: null };

console.log(user.profile?.name); // undefined (no error)


Sin esto, tirarÃ­as:

TypeError: Cannot read properties of null

âœ”ï¸ Cadena completa
user?.address?.street?.name

âœ”ï¸ Optional call
user.getName?.();

ğŸŸ§ 3. Promise.allSettled
â“ Â¿QuÃ© hace?

Ejecuta todas las promesas, aunque alguna falle.

Devuelve:

{status: "fulfilled", value: ...}

{status: "rejected", reason: ...}

âœ”ï¸ Ejemplo
const results = await Promise.allSettled([
  fetch("/ok"),
  fetch("/missing"),    // falla
  Promise.resolve(123),
]);

console.log(results);


âœ”ï¸ En allSettled ninguna promesa detiene el proceso.
âŒ En Promise.all, una falla rompe todo.

ğŸŸ¦ 4. Logical Assignment (&&=, ||=, ??=)

Estas combinan operadores lÃ³gicos con asignaciÃ³n.

âœ”ï¸ ||= â€” Asigna si el valor es falsy:
let name = "";
name ||= "Anon";  
console.log(name); // "Anon"


Similar a: name = name || "Anon"

âœ”ï¸ &&= â€” Asigna si el valor es truthy:
let a = 5;
a &&= 10; // 10

let b = 0;
b &&= 10; // 0

âœ”ï¸ ??= â€” Asigna si el valor es nullish:
let age = null;
age ??= 18;  
console.log(age); // 18


Es la combinaciÃ³n natural de ?? con =.

ğŸŸª 5. WeakRefs
â“ Â¿QuÃ© son?

Permiten referenciar objetos sin evitar que el GC (garbage collector) los elimine.

Sirven para:

caches automÃ¡ticas

estructuras para objetos temporales

listeners dÃ©biles

âœ”ï¸ Ejemplo bÃ¡sico
let obj = { name: "Josue" };

const ref = new WeakRef(obj);

console.log(ref.deref().name); // "Josue"

obj = null;           // El GC puede eliminarlo

â—Advertencia

Los WeakRefs deben usarse con cuidado.
No garantizan cuÃ¡ndo se elimina el objeto â€” es no determinista.

ğŸŸ« 6. Temporal API (Fechas modernas â€“ ES2025+)

Javascript tenÃ­a un problema enorme: Date es inconsistente.

La nueva Temporal API es la soluciÃ³n moderna.

âœ”ï¸ Objetos clave

Temporal.Now

Temporal.PlainDate

Temporal.PlainDateTime

Temporal.TimeZone

Temporal.Duration

âœ”ï¸ Ejemplo
const today = Temporal.Now.plainDateISO();
console.log(today.toString()); // "2025-03-12"


Fechas sin zona horaria:

const date = Temporal.PlainDate.from("2025-10-13");
console.log(date.add({ days: 5 }).toString()); 


Duraciones:

const d = Temporal.Duration.from({ days: 3, hours: 4 });


âœ”ï¸ Mucho mÃ¡s consistente, predecible y seguro que new Date().

ğŸŸ¥ 7. RegExp Improvements
âœ”ï¸ Nuevas flags

d â€” indices (.indices)

s â€” dotAll

u â€” unicode full escapes

v â€” unicode sets (mÃ¡s moderno)

âœ”ï¸ Ejemplo .indices (ES2022)
const r = /(hello)/d;
const m = r.exec("hello world");

console.log(m.indices); 
// [[0, 5], [0, 5]]


Permite saber exactamente dÃ³nde empieza y termina cada grupo.

âœ”ï¸ Unicode Sets (ES2024+)
/\p{Letter}/v.test("Ã±"); // true


Unicode real, no hacks.

ğŸŸ¦ 8. Top-Level Await

Antes solo podÃ­as usar await dentro de funciones async.

Ahora puedes usarlo directamente en mÃ³dulos ES.

âœ”ï¸ Ejemplo:
const data = await fetch("https://api.com/user").then(r => r.json());
console.log(data);


Solo funciona en mÃ³dulos import/export.

âœ”ï¸ Implica:

MÃ³dulos pueden â€œbloquearseâ€ mientras esperan datos

Permite inicializaciÃ³n asincrÃ³nica mÃ¡s limpia

ğŸŸ© 9. Decorators (Finalizados ES2023/2024)

Decorators permiten aÃ±adir comportamiento a:

clases

mÃ©todos

propiedades

getters/setters

âœ”ï¸ Ejemplo bÃ¡sico:
function Log(target: any, name: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log("Llamando:", name);
    return original.apply(this, args);
  }
}

class User {
  @Log
  sayHi() {
    console.log("Hola!");
  }
}

new User().sayHi();


Salida:

Llamando: sayHi
Hola!


â¡ï¸ En TypeScript ya se usan hace aÃ±os, pero ahora estÃ¡n estandarizados.

ğŸŸ« 10. Records & Tuples (In-process ES2025+)

Son valores inmutables profundamente.

âœ”ï¸ Record (#{})
const r = #{
  name: "Josue",
  age: 33
};

console.log(r.name); // "Josue"


Profundamente inmutable

Estructuralmente comparado (no por referencia)

âœ”ï¸ Tuple (#[])
const t = #[1, 2, 3];

t[0] = 10; // âŒ Error â€” inmutable

âœ”ï¸ ComparaciÃ³n profunda:
#[1, 2] === #[1, 2]; // true
[1, 2] === [1, 2];   // false (referencia)


Esto es enorme para programaciÃ³n funcional y modelos de datos inmutables.

ğŸ RESUMEN (CLARO Y PROFESIONAL)
Feature	QuÃ© resuelve
??	Valores nullish
?.	Acceso seguro a propiedades
Promise.allSettled	Ejecutar promesas sin cancelar por errores
`&&=	
WeakRefs	Memoria flexible y caches
Temporal API	Fechas modernas
RegExp improvements	Regex modernas y unicode real
Top-Level Await	MÃ³dulos asincrÃ³nicos
Decorators	MetaprogramaciÃ³n
Records & Tuples	Inmutabilidad profunda