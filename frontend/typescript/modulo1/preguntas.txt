Como funciona typescript? Los internals? Como es que es un superset de js?

TypeScript solo existe en tiempo de compilaci√≥n.
El navegador no sabe que es 

‚úîÔ∏è Internamente TypeScript hace tres tareas:
1. Parsing (leer tu c√≥digo .ts y construir un AST) (arbol sintactico)
2. Type Checking (comprobar que todo est√° bien tipado)
3. Code Generation (generar c√≥digo .js)


‚û° Todo JavaScript v√°lido ES v√°lido en TypeScript
‚û° TypeScript agrega una capa extra:


-----------
Por que hay 2 tipos de tipado y no solo uno? Que sucede intermanete que lleva a esta diferencia fucniomal para tener tanto ptipado estatico como tipado dianmico ( un en tiempo de compilacion , y el otro en tiempo de ejecucion respectivamente)

1. Tipado est√°tico (TypeScript)
Sucede en compilaci√≥n
Detecta errores ANTES de ejecutar
No existe en runtime
Ayuda al editor y al compilador
Ejemplo:
let x: number = 10;
x = "hola"; // ‚ùå Error de compilaci√≥n


‚úîÔ∏è 2. Tipado din√°mico (JavaScript)
Sucede durante ejecuci√≥n
Los tipos se determinan en runtime
Puedes reasignar tipos f√°cilment


---------------

Explica los cambios de javascript ( ecmascript de 2015 a 2025) para tener un entendeimiento evolutivo del leguaje pricipalmente para saber las poteincaius de js y como se relaciona con typescript

üü® 4. Evoluci√≥n de JavaScript (ES2015 ‚Üí ES2025)

üü¶ ES2015 (ES6) ‚Üí revolucion√≥ JavaScript
Fue la versi√≥n M√ÅS grande de la historia.
let, const
Arrow functions
Classes
Template strings
Modules import / export
Promises
Destructuring
Spread/rest
Map, Set
Symbol
Default parameters

‚û° Aqu√≠ naci√≥ el JS moderno que TypeScript adopta.
üüß ES2016‚Äì2020
async/await
includes()
Object.entries, Object.values
Optional catch binding
BigInt
Nullish coalescing (??)
Optional chaining (?.)
Promise.allSettled

üü© ES2021‚Äì2025
Logical assignment (&&=, ||=, ??=)
WeakRefs
Temporal API (fechas moderna)
RegExp improvements
Top-level await
Decorators (finalized)
Records & Tuples (in proceso ES2025+)
‚û° Muchas de estas mejoras se reflejan en TS, que se adelanta al est√°ndar.




Explica esta parte del compilador como funciona de manera interna y en detalle explica : 
"module": "commonjs",        // Sistema de m√≥dulos (Node) o "esnext" para esm
Esto controla c√≥mo TypeScript genera import/export en JavaScript.
ejemplos: 
‚úîÔ∏è commonjs (Node cl√°sico)

Genera: 
const fs = require("fs");
module.exports = ...
Usado en Node.js antes de ESModules.


‚úîÔ∏è esnext / es2020 / esmodule (import/export moderno)
Genera:
import fs from "fs";
export default ...
Usado en:
frontend moderno
bundlers
Node 14+ con "type": "module"
-----------------------

Explica  como funciona undefined y null en typescript 
Esplcia cuando utilia run o u otro 
‚úîÔ∏è undefined
Significa ‚Äúvariable declarada pero sin valor‚Äù.
let x: number | undefined;

‚úîÔ∏è null
Significa ‚Äúausencia intencional de valor‚Äù.
let y: string | null;

‚ùó En modo strict
null y undefined no pueden asignarse a otros tipos.







Provee algunos ejemplos del modo strict. 



no entiendo cual es la ventaja de utilizar never como tipo de retorno en una funcion 
‚û° Es una herramienta brutal para validaci√≥n exhaustiva en arquitecturas complejas.



provee ejemplos de cuando utilizar type y cuando utilizar interface y cuando class de maner aqu epermtia codigo esaclable consistenrte y mantenible 
por que utilizar una tupla como esta en lugar de un objeto : [string, number, boolean] que represente: nombre, edad, est√°Activo.

üü¶ 10. ¬øPor qu√© usar una tupla en lugar de un objeto?
Tupla:
const user: [string, number, boolean] = ["Josue", 33, true];

Objeto:
const user = { name: "Josue", age: 33, isActive: true };
‚úîÔ∏è Ventajas de tupla
Tama√±o fijo
Orden fijo
M√°s eficiente
√ötil en programaci√≥n funcional
Ejemplos comunes:
[key, value] en Map
Retornos m√∫ltiples:
const [data, error] = useFetch();

‚ùå Desventaja
Menos legible
No se sabe qu√© significa cada posici√≥n sin contexto
Por eso en la mayor√≠a de proyectos preferimos objetos, excepto para casos muy espec√≠ficos.




Cuando utilizar instanceof y cuando utilizar "in" 


‚úîÔ∏è Cuando usar instanceof (clases reales)
Solo funciona con clases reales (constructores).
if (obj instanceof Person) { ... }


‚úîÔ∏è Cuando usar "in" (objetos literales y types)

Funciona con objetos literales y types.
if ("bark" in animal) { ... } //valida ai existe una funcion en el type o en el objeto. 

√ösalo cuando:
-Trabajas con unions:
type Dog = { bark: () => void }
type Cat = { meow: () => void }

-Trabajas con interfaces
No tienes clases
----------


Cuando utilizar cada una de las siguientes opciones del compilador: 
| M√©todo          | Uso recomendado                             |
| --------------- | ------------------------------------------- |
| **tsc + node**  | Para proyectos reales, builds serios        |
| **ts-node**     | Scripts r√°pidos, pr√°ctica, desarrollo local |
| **npx ts-node** | Para ejecutar TS sin instalaciones          |



como funciona cada una de estas caracteristicas de ES: 
Nullish coalescing (??) - validar nulos o undefined
Optional chaining (?.)
Promise.allSettled
Logical assignment (&&=, ||=, ??=)
WeakRefs
Temporal API (fechas moderna)
RegExp improvements
Top-level await
Decorators (finalized)
Records & Tuples (in proceso ES2025+)

--------------------



////////Modulo 2 

Como se debe utilizar el tipado en typescript para optimizar el codigo?
b) Evita any, usa unknown o tipos espec√≠ficos

c) Usa tipos de dominio, no solo string | number everywhere
En lugar de:
type Role = string; // poco informativo
Mejor:
type Role = 'admin' | 'editor' | 'viewer'; // uni√≥n literal

1.3. Usa utilidades de TS para reducir c√≥digo repetido
Partial<T> ‚Äì todos los campos opcionales.
Pick<T, K> ‚Äì sub-tipo con algunas propiedades.
Record<K, T> ‚Äì objetos-indexados tipados (lo veremos abajo).


///////Como utilizar symbol ? 

symbol es un tipo primitivo que representa un identificador √∫nico.
const s1 = Symbol('id');
const s2 = Symbol('id');
console.log(s1 === s2); // false (siempre √∫nicos)

Se usan sobre todo para:
Claves ‚Äúocultas‚Äù en objetos (no colisionan con otras keys).ejemplo: 
const internalId = Symbol('internalId');

type WithInternal = {
  [internalId]: string;
  name: string;
};

const obj: WithInternal = {
  [internalId]: 'abc-123',
  name: 'Josue',
};

// No sale en for...in
for (const key in obj) {
  console.log(key); // solo 'name'
}

Proteger propiedades internas.
Implementar protocolos con well-known symbols (Symbol.iterator, etc.).




///////Como utilizar bigint? cuando? 

3.1. ¬øQu√© es?
JS number es un double (64 bits), con m√°ximo seguro 2^53 - 1.
bigint permite manejar enteros arbitrariamente grandes:

const normalMax = Number.MAX_SAFE_INTEGER; // 9007199254740991
const big: bigint = 9007199254740991n + 10n; // OK

Creaci√≥n:
const a = 123n;           // literal
const b = BigInt('123');  // funci√≥n


3.2. Reglas importantes
No se pueden mezclar directamente con number:
const x = 10n + 5; // ‚ùå Error
const x2 = 10n + BigInt(5); // ‚úÖ


No se pueden usar en Math.*.
JSO
3.3. ¬øCu√°ndo usarlo?
IDs muy grandes (por ejemplo, IDs de DB o blockchains).
Contadores gigantes (logs, eventos, etc.).
C√°lculos matem√°ticos donde no quieres perder precisi√≥n de enteros.
Ejemplo simple:
type BigIntId = bigint;

interface Entity {
  id: BigIntId;
  name: string;
}

const entity: Entity = {
  id: 12345678901234567890n,
  name: 'Big Entity',
};


En front puro (React/Angular), no es muy com√∫n salvo que:
El backend te d√© IDs como bigint (ej. GraphQL scalars), o
Hagas l√≥gica criptogr√°fica / blockchain en el navegador.




Cuando y como utilizar weakrefs  y records en react  y angular? utiliza ejemplos tambien.


WeakRef (y WeakMap, WeakSet) ‚Üí API de JS para referencias d√©biles.

Record<K, T> ‚Üí utility type de TypeScript (muy √∫til).

4.1. WeakRef / WeakMap / WeakSet
¬øQu√© es una referencia d√©bil?
Una WeakRef NO evita que el GC (garbage collector) borre el objeto.
Te permite decir: ‚Äúsi el objeto existe, √∫salo; si el GC lo limpi√≥, no pasa nada‚Äù.

const obj = { name: 'heavy' };
const ref = new WeakRef(obj);

// En alg√∫n momento...
const deref = ref.deref();
if (deref) {
  console.log(deref.name);
} else {
  // El objeto fue recogido por GC
}


En la pr√°ctica:
Son muy avanzadas.
Se usan para caches que no deben impedir GC.
WeakMap / WeakSet (m√°s comunes que WeakRef)
const wm = new WeakMap<object, string>();

const key = {};
wm.set(key, 'valor');
// Si ‚Äúkey‚Äù se queda sin referencias en el c√≥digo,
// el GC puede limpiar la entrada del WeakMap.









Record.


4.2. Record<K, T> en TypeScript: este s√≠ lo usar√°s un mont√≥n

Record<K, T> es un tipo utilitario que representa:

‚ÄúUn objeto cuyas claves son de tipo K y el valor de cada clave es tipo T‚Äù.

type ParticipantType = 'gold' | 'silver' | 'bronze';

type ConfigPorTipo = Record<ParticipantType, { color: string; priority: number }>;

const config: ConfigPorTipo = {
  gold: { color: 'gold', priority: 1 },
  silver: { color: 'silver', priority: 2 },
  bronze: { color: 'brown', priority: 3 },
};


Ventajas:

El compilador te obliga a definir todas las keys.

Si agregas un nuevo ParticipantType, el error te lleva directo a todos los sitios donde falta.

React ‚Äì usar Record en estado
type ParticipantType = 'gold' | 'silver' | 'bronze';

interface Participant {
  id: string;
  name: string;
  type: ParticipantType;
}

// Mapa tipo -> lista de participantes
type ParticipantsByType = Record<ParticipantType, Participant[]>;

const [byType, setByType] = useState<ParticipantsByType>({
  gold: [],
  silver: [],
  bronze: [],
});


Si ma√±ana agregas 'volunteer' a ParticipantType, TS te dir√° que byType ya no est√° completo.

Angular ‚Äì usar Record en configs / servicios
export type Channel = 'web' | 'app' | 'kiosk';

export interface ChannelConfig {
  baseUrl: string;
  timeout: number;
}

@Injectable({ providedIn: 'root' })
export class ChannelConfigService {
  private readonly config: Record<Channel, ChannelConfig> = {
    web:   { baseUrl: '/api/web', timeout: 5000 },
    app:   { baseUrl: '/api/app', timeout: 7000 },
    kiosk: { baseUrl: '/api/kiosk', timeout: 9000 },
  };

  getConfig(channel: Channel): ChannelConfig {
    return this.config[channel];
  }
}


Con Record, si agregas un nuevo Channel, TS obliga a definir su config.