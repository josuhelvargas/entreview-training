Como funciona typescript? Los internals? Como es que es un superset de js?

TypeScript solo existe en tiempo de compilaci√≥n.
El navegador no sabe que es 

‚úîÔ∏è Internamente TypeScript hace tres tareas:
1. Parsing (leer tu c√≥digo .ts y construir un AST) (arbol sintactico)
2. Type Checking (comprobar que todo est√° bien tipado)
3. Code Generation (generar c√≥digo .js)


‚û° Todo JavaScript v√°lido ES v√°lido en TypeScript
‚û° TypeScript agrega una capa extra:


-----------
Por que hay 2 tipos de tipado y no solo uno? Que sucede intermanete que lleva a esta diferencia fucniomal para tener tanto ptipado estatico como tipado dianmico ( un en tiempo de compilacion , y el otro en tiempo de ejecucion respectivamente)

1. Tipado est√°tico (TypeScript)
Sucede en compilaci√≥n
Detecta errores ANTES de ejecutar
No existe en runtime
Ayuda al editor y al compilador
Ejemplo:
let x: number = 10;
x = "hola"; // ‚ùå Error de compilaci√≥n


‚úîÔ∏è 2. Tipado din√°mico (JavaScript)
Sucede durante ejecuci√≥n
Los tipos se determinan en runtime
Puedes reasignar tipos f√°cilment


---------------

Explica los cambios de javascript ( ecmascript de 2015 a 2025) para tener un entendeimiento evolutivo del leguaje pricipalmente para saber las poteincaius de js y como se relaciona con typescript

üü® 4. Evoluci√≥n de JavaScript (ES2015 ‚Üí ES2025)

üü¶ ES2015 (ES6) ‚Üí revolucion√≥ JavaScript
Fue la versi√≥n M√ÅS grande de la historia.
let, const
Arrow functions
Classes
Template strings
Modules import / export
Promises
Destructuring
Spread/rest
Map, Set
Symbol
Default parameters

‚û° Aqu√≠ naci√≥ el JS moderno que TypeScript adopta.
üüß ES2016‚Äì2020
async/await
includes()
Object.entries, Object.values
Optional catch binding
BigInt
Nullish coalescing (??)
Optional chaining (?.)
Promise.allSettled

üü© ES2021‚Äì2025
Logical assignment (&&=, ||=, ??=)
WeakRefs
Temporal API (fechas moderna)
RegExp improvements
Top-level await
Decorators (finalized)
Records & Tuples (in proceso ES2025+)
‚û° Muchas de estas mejoras se reflejan en TS, que se adelanta al est√°ndar.




Explica esta parte del compilador como funciona de manera interna y en detalle explica : 
"module": "commonjs",        // Sistema de m√≥dulos (Node) o "esnext" para esm
Esto controla c√≥mo TypeScript genera import/export en JavaScript.
ejemplos: 
‚úîÔ∏è commonjs (Node cl√°sico)

Genera: 
const fs = require("fs");
module.exports = ...
Usado en Node.js antes de ESModules.


‚úîÔ∏è esnext / es2020 / esmodule (import/export moderno)
Genera:
import fs from "fs";
export default ...
Usado en:
frontend moderno
bundlers
Node 14+ con "type": "module"
-----------------------

Explica  como funciona undefined y null en typescript 
Esplcia cuando utilia run o u otro 
‚úîÔ∏è undefined
Significa ‚Äúvariable declarada pero sin valor‚Äù.
let x: number | undefined;

‚úîÔ∏è null
Significa ‚Äúausencia intencional de valor‚Äù.
let y: string | null;

‚ùó En modo strict
null y undefined no pueden asignarse a otros tipos.







Provee algunos ejemplos del modo strict. 



no entiendo cual es la ventaja de utilizar never como tipo de retorno en una funcion 
‚û° Es una herramienta brutal para validaci√≥n exhaustiva en arquitecturas complejas.



provee ejemplos de cuando utilizar type y cuando utilizar interface y cuando class de maner aqu epermtia codigo esaclable consistenrte y mantenible 
por que utilizar una tupla como esta en lugar de un objeto : [string, number, boolean] que represente: nombre, edad, est√°Activo.

üü¶ 10. ¬øPor qu√© usar una tupla en lugar de un objeto?
Tupla:
const user: [string, number, boolean] = ["Josue", 33, true];

Objeto:
const user = { name: "Josue", age: 33, isActive: true };
‚úîÔ∏è Ventajas de tupla
Tama√±o fijo
Orden fijo
M√°s eficiente
√ötil en programaci√≥n funcional
Ejemplos comunes:
[key, value] en Map
Retornos m√∫ltiples:
const [data, error] = useFetch();

‚ùå Desventaja
Menos legible
No se sabe qu√© significa cada posici√≥n sin contexto
Por eso en la mayor√≠a de proyectos preferimos objetos, excepto para casos muy espec√≠ficos.




Cuando utilizar instanceof y cuando utilizar "in" 


‚úîÔ∏è Cuando usar instanceof (clases reales)
Solo funciona con clases reales (constructores).
if (obj instanceof Person) { ... }


‚úîÔ∏è Cuando usar "in" (objetos literales y types)

Funciona con objetos literales y types.
if ("bark" in animal) { ... } //valida ai existe una funcion en el type o en el objeto. 

√ösalo cuando:
-Trabajas con unions:
type Dog = { bark: () => void }
type Cat = { meow: () => void }

-Trabajas con interfaces
No tienes clases
----------


Cuando utilizar cada una de las siguientes opciones del compilador: 
| M√©todo          | Uso recomendado                             |
| --------------- | ------------------------------------------- |
| **tsc + node**  | Para proyectos reales, builds serios        |
| **ts-node**     | Scripts r√°pidos, pr√°ctica, desarrollo local |
| **npx ts-node** | Para ejecutar TS sin instalaciones          |



como funciona cada una de estas caracteristicas de ES: 
Nullish coalescing (??) - validar nulos o undefined
Optional chaining (?.)
Promise.allSettled
Logical assignment (&&=, ||=, ??=)
WeakRefs
Temporal API (fechas moderna)
RegExp improvements
Top-level await
Decorators (finalized)
Records & Tuples (in proceso ES2025+)