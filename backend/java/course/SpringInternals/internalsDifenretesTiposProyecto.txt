ğŸ§  1. Â¿QuÃ© es realmente Spring por dentro?

Spring no es â€œanotaciones mÃ¡gicasâ€:
es un gran contenedor de objetos que crea, conecta, configura y gestiona tus clases.

El corazÃ³n de Spring es:

âœ”ï¸ IoC Container
âœ”ï¸ BeanFactory
âœ”ï¸ ApplicationContext

Toda la magia parte de ahÃ­.

Cuando tu app arranca, Spring hace esto:

Escanea tus clases

Crea beans (objetos administrados por Spring)

Resuelve dependencias (DI)

Genera proxies (AOP)

Activa auto-configuraciones

Arranca el servidor embebido (Tomcat/Netty)

Expone endpoints

Vamos paso a paso.

ğŸŸ¦ 2. Internals: IoC Container
âš™ï¸ Â¿QuÃ© pasa al iniciar la app?

Cuando ejecutas:

SpringApplication.run(App.class, args)


Spring crea un contenedor interno:

ApplicationContext (IMEGA OBJETO)


Ese contexto contiene:

beans creados

configuraciÃ³n

eventos

perfiles activos

listeners

lifecycle hooks

proxies AOP

Es literalmente â€œla caja donde vive toda tu aplicaciÃ³nâ€.

ğŸŸ¦ 3. Internals: BeanFactory

El BeanFactory es el core del contenedor.

Funciones internas:

âœ”ï¸ Crear objetos
âœ”ï¸ Guardarlos en un mapa interno
âœ”ï¸ Resolver dependencias
âœ”ï¸ Administrar scopes
âœ”ï¸ Aplicar AOP (proxies)
âœ”ï¸ Manejar el ciclo de vida (@PostConstruct, @PreDestroy)

Internamente mantiene algo asÃ­ como:

Map<String, Object> singletonObjects
Map<String, BeanDefinition> beanDefinitions


Un BeanDefinition describe:

tipo de clase

constructor

dependencias

scope

anotaciones

ğŸŸ¦ 4. Â¿CÃ³mo Spring crea un bean internamente?
1. Escanea clases anotadas con:

@Component

@Service

@Repository

@Controller

@RestController

2. Genera un BeanDefinition para cada una.
3. Dependiendo del scope:

Si es singleton â†’ crea una sola instancia e la cachea.

Si es prototype â†’ crea una nueva cada vez.

4. InyecciÃ³n de dependencias:

Cuando Spring necesita crear un bean:

Bean X â†’ requiere Bean Y â†’ requiere Bean Z


Spring hace un grÃ¡fico de dependencias.

5. Usa constructor injection como preferido.
ğŸŸ¦ 5. Internals: Dependency Injection (DI)

Cuando Spring resuelve dependencias:

Lee el constructor

Busca los beans necesarios

Se asegura de crearlos primero

Inyecta la instancia final

Internamente hay un mecanismo llamado:

ğŸ‘‰ DependencyDescriptor

Ese objeto dice:

quÃ© tipo necesita

si es requerido

si es opcional

si hay calificador (@Qualifier)

si hay mÃºltiples implementaciones

Spring usa heurÃ­sticas para decidir quÃ© inyectar.

ğŸŸ¦ 6. Internals: AOP (Aspect Oriented Programming)

AquÃ­ viene la magia del proxy.

Spring crea proxies para ciertas clases, por ejemplo:

mÃ©todos con seguridad (@PreAuthorize)

transacciones (@Transactional)

logging

mÃ©tricas

rate limit

retrys

circuit breakers

Â¿CÃ³mo son los proxies?

Dynamic proxies JDK â†’ si tu clase implementa interfaces

CGLIB proxies â†’ si tu clase NO implementa interfaces

Internamente lo que pasa es:

En vez de usar tu clase directamente, Spring genera una clase "envoltura":

UserServiceProxy extends UserService
    intercepta mÃ©todo1()
    ejecuta before/after
    delega al mÃ©todo original


Entonces cuando llamas:

userService.save()


realmente llamas:

proxy.save() â†’ interceptor â†’ mÃ©todo real

ğŸŸ¦ 7. Internals: ApplicationContext

ApplicationContext es como un â€œBeanFactory plusâ€.

Incluye:

Eventos (ApplicationEventPublisher)

InternacionalizaciÃ³n (i18n)

IntegraciÃ³n con Spring MVC

Mecanismo de refresh

Profiles

Hook para startup/shutdown

Web server embebido

Cuando arranca Spring Boot:

Crea el contexto

Registra los beans de auto-configuraciÃ³n

Registra listeners

Activa el escaneo de componentes

Levanta el servidor embebido (Tomcat/Jetty/Netty)

Expone endpoints

ğŸŸ¦ 8. Internals: Auto-configuration de Spring Boot

Esto es lo mÃ¡s impresionante.

Spring Boot busca las clases en:

META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports


Cada clase de configuraciÃ³n tiene condiciones:

@ConditionalOnClass
@ConditionalOnMissingBean
@ConditionalOnProperty
@ConditionalOnResource


Es decir:

â€œConfigura X si Y existeâ€.

Ejemplo:

@ConditionalOnClass(DataSource.class)
public class DataSourceAutoConfiguration {}


Si en tu classpath estÃ¡ HikariCP â†’ Spring Boot auto-configura un pool de conexiones.

ğŸŸ¦ 9. Â¿QuÃ© INICIA realmente Spring Boot al arranque? (Secuencia real)

Resumen del arranque:

1. SpringApplication se crea
2. Prepara el environment
3. Determina los profiles
4. Carga propiedades
5. Crea ApplicationContext
6. Registra auto-configuraciones
7. Refresca el contexto
8. Inicializa los beans
9. Aplica AOP
10. Inicia el servidor web
11. Ejecuta CommandLineRunners
12. App lista para servir requests
ğŸŸ¦ 10. Internals: Manejo de ConfiguraciÃ³n

Las propiedades se cargan en este orden de prioridad:

Command-line args

Variables de entorno

Archivo externo (config dir)

application.yml

application-{profile}.yml

Defaults internos de Spring Boot

Spring crea un objeto gigante llamado:

Environment


AhÃ­ pone todas las properties fusionadas.

Luego hace binding automÃ¡tico con:

@ConfigurationProperties

ğŸŸ¦ 11. Internals: Spring MVC / WebFlux

Si usas Spring Web MVC:

arranca un DispatcherServlet

mapea rutas

llama handlers

serializa JSON vÃ­a Jackson

resuelve excepciones

aplica AOP

mueve datos entre capas

El DispatcherServlet funciona igual que un router express pero 1000 veces mÃ¡s sofisticado.

ğŸŸ¦ 12. Internals de Spring Validations

Cuando usas:

@Valid UserDTO dto


Spring:

Crea un bean Validator

Usa Hibernate Validator (implementaciÃ³n Jakarta Validation)

Intercepta el mÃ©todo del controller

Valida parÃ¡metros

Si falla â†’ lanza MethodArgumentNotValidException

Tu @RestControllerAdvice lo captura

ğŸŸ¦ 13. Internals: Logging

Spring Boot usa:

commons-logging (API antigua)

SLF4J (API moderna)

Logback (implementaciÃ³n por defecto)

Todos los logs pasan por una capa de abstracciÃ³n, por eso puedes cambiar de Logback â†’ Log4J2 â†’ Log4J sin reescribir cÃ³digo.

ğŸŸ¦ 14. Internals: Observability con Micrometer

Cuando haces un request:

Se crea un contexto de trazas

Se asigna un traceId y spanId

Cada mÃ©todo puede crear spans

Se exporta a Prometheus/OpenTelemetry

Puedes ver:

tiempo por endpoint

latencias

errores

GC, CPU, heap

pool de threads

metrics custom

Esto ya es estÃ¡ndar enterprise.

ğŸŸ¦ 15. Internals: CÃ³mo Spring levanta un servidor web

Cuando usas starter-web:

Spring detecta:

Tomcat

DispatcherServlet

MappingHandler

WebMvcConfigurer

Spring Boot crea un:

TomcatWebServer


Que por default escucha en:

0.0.0.0:8080


y monta el DispatcherServlet.

ğŸŸ¦ 16. Internals: Ciclo de vida de Spring

Crear contenedor

Cargar configs

Registrar beans

Crear singletons

PostConstruct â†’ inicializaciones

App lista

On shutdown:

PreDestroy

cerrar beans

liberar resources

ğŸ¯ Â¿Quieres profundizar mÃ¡s?

Puedo explicarte:

Internals de InyecciÃ³n por constructor vs field

CÃ³mo funciona exactamente un proxy AOP paso por paso

CÃ³mo funciona DispatcherServlet internamente

CÃ³mo arranca Spring Security

Lifecycle detallado de un request

CÃ³mo funciona Spring Cloud / Config Server / Feign por dentro

Internals de WebFlux (reactivo)

Solo dime por dÃ³nde seguimos y te lo destripo con gusto ğŸ˜ğŸ”¥