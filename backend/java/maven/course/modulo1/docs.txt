
Lee el POM actual

Busca el parent POM

Fusiona configuraciones

Expande propiedades ${ }

Activa perfiles

Aplica herencia

Construye un modelo completo del proyecto:



â‘¡ Resolver dependencias

El Artifact Resolver:

analiza dependencias declaradas

analiza dependencias transitivas

aplica reglas de conflicto

usa el mecanismo de â€œnearest definitionâ€

descarga artefactos al repositorio local

aplica versiones, scopes y exclusiones

â‘¢ Construir el â€œExecution Planâ€

Maven evalÃºa:

packaging (jar, war, pom)

ciclo de vida que corresponde

fases necesarias

plugins default para cada fase

Ejemplo para un proyecto jar:

Fase	         Plugin Default
validate	    maven-enforcer-plugin
compile	      maven-compiler-plugin
test	        maven-surefire-plugin
package	      maven-jar-plugin
install	      maven-install-plugin




â‘£ Ejecutar fases en orden

Cada fase llama plugins (goals) que ejecutan lÃ³gica Java.

Ejemplo real:

mvn clean install produce:

clean â†’ remove target directory

validate â†’ validate structure

compile â†’ javac

test â†’ run JUnit

package â†’ empaquetar .jar

install â†’ copiar al .m2




â‘¤ Reportar resultado

Al final Maven crea:

un Ã¡rbol de dependencias

un artefacto empaquetado

estados de ejecuciÃ³n

logs estructurados




ğŸ“˜ 3. Componentes internos de Maven

AquÃ­ tienes los mÃ³dulos internos que trabajan detrÃ¡s del build.

ğŸŸ¦ 1. POM Model Builder

Construye el modelo completo a partir del POM:

herencia

perfiles

propiedades

repositorios

plugins

Clase interna clave:

DefaultModelBuilder

ğŸŸ© 2. MavenProject

RepresentaciÃ³n en memoria del proyecto, contiene:

modelo completo

rutas

configuraciÃ³n build

lista de plugins

lista de dependencias

ejecuciÃ³n activa

Es el objeto principal dentro del ciclo de vida.

ğŸŸ§ 3. Plugin Manager

Invoca plugins y goals.

Responsabilidades:

localizar el plugin

cargar su metadata

descargarlo si no existe

crear su ClassLoader

ejecutar el goal

inyectar configuraciones del POM

ğŸŸ© 4. Lifecycle Executor

Define quÃ© fases ejecutar.

Arquitectura:

LifecycleMapping
ExecutionPlan
MojoExecutor


MOJO = "Maven plain Old Java Object" (un plugin).

ğŸŸ« 5. Artifact Resolver

Es el responsable de:

resolver dependencias

conflictos de versiones

descargar JARs

leer POMs transitivos

aplicar exclusions

ImplementaciÃ³n clave:

Aether (Apache Maven Resolver)

ğŸŸ¥ 6. Repositories System

Administra:

repositorio local (.m2)

repositorios remotos

mirrors

snapshots vs releases

ğŸŸ© 4. Ejercicios prÃ¡cticos para entender la arquitectura

Estos ejercicios estÃ¡n diseÃ±ados para mostrarte â€œlo que Maven escondeâ€.

ğŸ§ª EJERCICIO 1 â€“ Observa cÃ³mo Maven construye el modelo del POM

Ejecuta:

mvn help:effective-pom


ğŸ‘‰ VerÃ¡s cÃ³mo Maven:

combinÃ³ tu POM

combinÃ³ el padre

aÃ±adiÃ³ configuraciones default

aÃ±adiÃ³ plugins default

aÃ±adiÃ³ propiedades extra

Esto es literalmente el modelo en memoria.

ğŸ§ª EJERCICIO 2 â€“ Observa el Ã¡rbol real de dependencias

Ejecuta:

mvn dependency:tree


Preguntas:

Â¿quÃ© dependencias vienen transitivamente?

Â¿Maven resolviÃ³ conflictos?

Â¿de dÃ³nde viene cada versiÃ³n?

ğŸ§ª EJERCICIO 3 â€“ Observa el Execution Plan

Ejecuta:

mvn -X package


Busca la secciÃ³n:

--- execution plan for jar:jar ---


AllÃ­ encontrarÃ¡s:

fases

goals

plugins ejecutados

orden de ejecuciÃ³n

ğŸ§ª EJERCICIO 4 â€“ Observa cÃ³mo Maven resuelve un plugin

Ejecuta:

mvn help:describe -Dplugin=compiler


Preguntas:

Â¿QuÃ© goals tiene el plugin?

Â¿QuÃ© vida del ciclo soporta?

Â¿QuÃ© configuraciones acepta?

ğŸ§ª EJERCICIO 5 â€“ Crea un error de conflicto de versiones

Modifica una dependencia con dos versiones distintas:

<dependency>
  <groupId>commons-io</groupId>
  <artifactId>commons-io</artifactId>
  <version>2.5</version>
</dependency>

<dependency>
  <groupId>commons-io</groupId>
  <artifactId>commons-io</artifactId>
  <version>2.11.0</version>
</dependency>


Luego ejecuta:

mvn dependency:tree -Dverbose


VerÃ¡s cÃ³mo Maven decide una versiÃ³n usando:

nearest-wins

dependency management

path de resoluciÃ³n

ğŸ§ª EJERCICIO 6 â€“ Crea tu propio plugin MOJO

Crea un mÃ³dulo con:

mvn archetype:generate -Dfilter=mojo


Implementa un plugin sencillo que imprima:

System.out.println("Hola desde un plugin!");


InstÃ¡lalo:

mvn install


Y ejecÃºtalo:

mvn tuplugin:hello


AquÃ­ verÃ¡s:

cÃ³mo los plugins son artefactos como cualquier dependencia

cÃ³mo Maven los carga con su propio ClassLoader

cÃ³mo tus goals se integran al ciclo

ğŸŸª EJERCICIO 7 â€“ Modifica el ciclo de vida

En tu POM agrega:

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-antrun-plugin</artifactId>
  <executions>
    <execution>
      <phase>validate</phase>
      <goals>
        <goal>run</goal>
      </goals>
      <configuration>
        <target>
          <echo>Validando proyecto... ğŸ”</echo>
        </target>
      </configuration>
    </execution>
  </executions>
</plugin>


Ejecuta:

mvn validate


VerÃ¡s cÃ³mo Maven integra el nuevo goal dentro de su Execution Plan.

ğŸ‰ Cierre del MÃ³dulo

Ya entiendes:

cÃ³mo piensa Maven

cÃ³mo construye su modelo

cÃ³mo resuelve dependencias

cÃ³mo decide la ejecuciÃ³n

quÃ© mÃ³dulos participan

cÃ³mo funciona el ciclo de vida

cÃ³mo instalar y ejecutar plugins

cÃ³mo inspeccionar la arquitectura interna











El POM da info respecto a la calidad  del proyecto :
    1.Registro de cambios creado directamente desde el control de cÃ³digo fuente
    2.Fuentes con referencias cruzadas
    3.Listas de correo gestionadas por el proyecto
    4.Dependencias utilizadas por el proyecto
    5.Informes de pruebas unitarias




Que es mejor: 
Hacer que los casos de prueba configuren su propio entorno en lugar de personalizar la compilaciÃ³n para la preparaciÃ³n de pruebas?    




Un Mojo es la unidad ejecutable de Maven; cada goal es un Mojo. Los Mojos se implementan extendiendo AbstractMojo, que define el mÃ©todo execute() y ofrece integraciÃ³n total con Maven (inyecciÃ³n de parÃ¡metros, phases, logging, lifecycle). Los plugins de Maven son simplemente colecciones de Mojos mapeados a goals. Se usan para crear lÃ³gica custom dentro del ciclo de vida de Maven, como generar recursos, validar reglas o preparar entornos corporativos. Gracias a Mojos, se puede extender Maven de forma nativa y consistente.


@Mojo(
  name = "create-build-info",
  defaultPhase = LifecyclePhase.PREPARE_PACKAGE
)
public class BuildInfoMojo extends AbstractMojo {

    @Parameter(defaultValue = "${project.version}")
    private String version;

    @Parameter(defaultValue = "${project.build.directory}")
    private String target;

    @Override
    public void execute() throws MojoExecutionException {
        try {
            File out = new File(target, "build-info.json");
            String json = "{ \"version\": \"" + version + "\" }";
            Files.writeString(out.toPath(), json);
            getLog().info("build-info.json created.");
        } catch (Exception e) {
            throw new MojoExecutionException("Failed to write file", e);
        }
    }
}