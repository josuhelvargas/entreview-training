En equ ecosn ite resovler dependecias en maven con usa el mecanismo de â€œnearest definitionâ€

UN EJEMPLO ULTRA SIMPLE (para que quede clarÃ­simo)

Proyecto A:

A
â””â”€â”€ B
      â””â”€â”€ commons-lang3:3.1


Ahora B tambiÃ©n depende de D:

A
â””â”€â”€ B
      â””â”€â”€ D
            â””â”€â”€ commons-lang3:3.12


Distancias:

commons-lang3:3.1 â†’ 2 saltos (A â†’ B â†’ commons-lang3)

commons-lang3:3.12 â†’ 3 saltos (A â†’ B â†’ D â†’ commons-lang3)

âœ”ï¸ Resultado â†’ Maven elige 3.1

porque estÃ¡ mÃ¡s cerca del root.
SÃ­ puedes tener mÃºltiples versiones declaradas en el Ã¡rbol, porque provienen de dependencias transitivas.

Pero Maven:

solo permite UNA versiÃ³n en el classpath final

las demÃ¡s las omite

usa reglas para decidir cuÃ¡l gana

Reglas, en orden de prioridad:

VersiÃ³n declarada directamente en <dependency> gana.

Si no, la versiÃ³n en <dependencyManagement> gana.

Si no, se aplica nearest definition (Ã¡rbol mÃ¡s corto).

Si hay empate, gana la dependencia listada primero en el pom.



////////////////////////////////////



como fuinciona aplicar versiones, scopes y exclusiones   ?
Esto es exactamente lo que hace el Artifact Resolver antes de elegir quÃ© dependencias entrarÃ¡n al classpath final.
Regla 1 â€” Si tÃº defines una versiÃ³n directa en <dependency>, gana esa.

Ejemplo:

<dependency>
  <groupId>com.google.guava</groupId>
  <artifactId>guava</artifactId>
  <version>31.0</version>
</dependency>


Aunque dependencias transitivas traigan guava 19, 20, 21â€¦

ğŸ‘‰ Maven siempre usarÃ¡ la 31.0 porque tÃº lo definiste directamente.

Regla 2 â€” Si no declaras versiÃ³n, manda <dependencyManagement>



Regla 3 â€” Si no hay versiÃ³n directa ni management â†’ â€œNearest Definitionâ€

Ya te lo expliquÃ© antes:

ğŸ‘‰ â€œcercanoâ€ = menor profundidad en el Ã¡rbol de dependencias



Regla 4 â€” Si hay empate â†’ gana la que aparece primero en tu <dependencies>


ğŸ¯ Resumen de versiones

Orden de prioridad:

Declarada directamente

Declarada en dependencyManagement

Nearest definition

Orden en el pom




Exclisones:
ğŸ§¨ 3. Â¿QuÃ© son las EXCLUSIONES?

Las exclusiones sirven para evitar que una dependencia transitiva entre al Ã¡rbol.

Ejemplo prÃ¡ctico:

Tu proyecto usa:

<dependency>
  <groupId>com.example</groupId>
  <artifactId>lib-A</artifactId>
</dependency>


Pero lib-A depende de:

slf4j-log4j12


Y tÃº NO quieres log4j
porque usas Logback.

Entonces excluyes:

<dependency>
  <groupId>com.example</groupId>
  <artifactId>lib-A</artifactId>
  <exclusions>
      <exclusion>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-log4j12</artifactId>
      </exclusion>
  </exclusions>
</dependency>


Ahora:

âš¡ Maven ignora el JAR conflictivo.
âš¡ No aparece en el Ã¡rbol.
âš¡ No se descarga.
âš¡ No entra al classpath.


/////////////////////////////////




qwue msignifica que maven al finalizar su ejecucion crea: 
estados de ejecuciÃ³n

logs estructurados
???

ğŸ§  Primero: Maven NO solo â€œcompila y yaâ€.
Durante un build, Maven va registrando:


decisiones que tomÃ³


fases que ejecutÃ³


resultados de cada plugin


tiempos


errores


warnings


rutas


configuraciones


versiones seleccionadas


dependencias omitidas


Y todo eso termina en:
ğŸ‘‰ execution state (estado de ejecuciÃ³n)
ğŸ‘‰ structured logs (logs estructurados)
Vamos a verlos uno por uno.

ğŸŸ¦ 1. Â¿QUÃ‰ ES EL â€œESTADO DE EJECUCIÃ“Nâ€ (Execution State)?
Cuando Maven termina de compilar, internamente deja un registro de TODAS las decisiones y resultados del build.
No lo ves como un archivo separado,
pero sÃ­ existe dentro del output y en estructuras internas.
Incluye:

âœ”ï¸ 1.1. QuÃ© fases se ejecutaron
Ejemplo:
validate
compile
test
package
install


âœ”ï¸ 1.2. QuÃ© plugins (goals) se ejecutaron en cada fase
Ejemplo:
maven-clean-plugin:3.2.0:clean
maven-resources-plugin:3.3.1:resources
maven-compiler-plugin:3.10.1:compile
maven-surefire-plugin:3.0.0-M8:test
maven-jar-plugin:3.3.0:jar
maven-install-plugin:3.1.0:install


âœ”ï¸ 1.3. Resultado de cada ejecuciÃ³n


SUCCESS


SKIPPED


FAILED


ERROR


NOT REQUIRED


Maven sabe exactamente quÃ© ejecutÃ³ y quÃ© omitiÃ³.

âœ”ï¸ 1.4. QuÃ© dependencias se resolvieron y cuÃ¡les se omitieron
Por ejemplo:
commons-io:2.6 (omitted for conflict with 2.8)


âœ”ï¸ 1.5. QuÃ© perfiles quedaron activos
Ejemplo:
Active Profiles: dev, docker


âœ”ï¸ 1.6. QuÃ© versiones de plugins y dependencias se usaron
Ejemplo:
Using compiler: javac 17
Using plugin maven-compiler-plugin:3.10.1
Effective Java version: 17


âœ”ï¸ 1.7. QuÃ© ruta tuvo el classpath final
Es decir, quÃ© JARs quedaron incluidos.

ğŸ¯ Â¿Por quÃ© es importante?
Porque los plugins posteriores pueden consultar esta data,
asÃ­ como herramientas de anÃ¡lisis, release plugins, etc.

ğŸŸ¨ Entonces: â€œExecution Stateâ€ = el registro completo del build
No es un archivo Ãºnico.
Es un estado interno que Maven guarda durante la ejecuciÃ³n
y representa:
ğŸ‘‰ TODO lo que Maven decidiÃ³
ğŸ‘‰ TODO lo que Maven ejecutÃ³
ğŸ‘‰ TODO lo que Maven omitiÃ³
ğŸ‘‰ TODO lo que resultÃ³ bien o mal

ğŸŸ§ 2. Â¿QuÃ© son los â€œLOGS ESTRUCTURADOSâ€?
Esto sÃ­ lo ves tÃº, porque aparece en consola.
Los logs estructurados son:
âœ”ï¸ mensajes con formato predecible
âœ”ï¸ generados por cada plugin
âœ”ï¸ categorizados
âœ”ï¸ jerÃ¡rquicos
âœ”ï¸ con niveles (INFO, WARNING, ERROR, DEBUG)
âœ”ï¸ con prefijos por plugin
Ejemplo tÃ­pico:
[INFO] --- maven-clean-plugin:3.2.0:clean (default-clean) ---
[INFO] Deleting /target
[INFO] --- maven-resources-plugin:3.3.1:resources (default-resources) ---
[INFO] Copying resources
[INFO] --- maven-compiler-plugin:3.10.1:compile (default-compile) ---
[INFO] Changes detected - recompiling the module!

Observa cÃ³mo:


cada secciÃ³n tiene nombre de plugin


cada paso estÃ¡ documentado


se incluyen versiones


los logs son reproducibles


son entendibles por herramientas CI/CD



ğŸ”¥ Â¿Por quÃ© se llaman â€œestructuradosâ€?
Porque siguen una convenciÃ³n estricta que permite a:


Jenkins


GitHub Actions


GitLab


SonarQube


IDEs


Analyzers


Parsing tools


interpretarlos automÃ¡ticamente.
Por ejemplo:
[WARNING] Using platform encoding (UTF-8 actually) invalid 

Siempre tiene:


Nivel del log â†’ [WARNING]


Plugin que lo emitiÃ³


Mensaje estandarizado


La estructura es intencional.

ğŸ§© Â¿QuÃ© incluye un log estructurado?


Inicio de plugins


Fin de plugins


Configuraciones aplicadas


Propiedades leÃ­das


Fases ejecutadas


Mensajes de error


DepuraciÃ³n (-X)


Ãrbol de dependencias


Artefactos omitidos


Artefactos ordenados


Versiones aplicadas


InformaciÃ³n de performance



ğŸ’¡ Tip: Con -X ves TODO el estado interno
Ejecuta:
mvn -X clean install

y verÃ¡s:


el execution plan completo


el Ã¡rbol interno exacto


los profiles cargados


resoluciÃ³n de dependencias


decisiones tomadas


plugins y sus configuraciones internas


el classpath final


logs estructurados extendidos


Es literalmente:
ğŸ‘‰ EL DIARIO INTERNO COMPLETO DEL BUILD.

ğŸ¯ RESUMEN SUPER SIMPLE
âœ”ï¸ â€œEstados de ejecuciÃ³nâ€
= Registro interno de quÃ© Maven hizo, cÃ³mo lo hizo, en quÃ© orden, quÃ© skipped, quÃ© fallÃ³.
âœ”ï¸ â€œLogs estructuradosâ€
= ImpresiÃ³n en consola de esos estados, organizada y formateada para lectura y anÃ¡lisis.

Si quieres te hago un ejemplo REAL:
Corro virtualmente un mvn clean install y te explico:


cada lÃ­nea


cada fase


cada plugin


cÃ³mo se genera su estado


cÃ³mo se interpreta el log


Â¿Quieres eso?







//////////

que significa eso de hewrencia a traves del pom

En Maven:

POM hijo â†’ â€œextiendeâ€ â†’ POM padre


El hijo hereda:

versiones de dependencias

configuraciones de plugins

repositorios

propiedades

perfiles

distribuciÃ³n

build defaults

mÃ³dulos

encoding

ciclo de compilaciÃ³n preconfigurado

informaciÃ³n del proyecto

Es decir:

ğŸ‘‰ Un POM no necesita repetir configuraciones
ğŸ‘‰ Puede definir SOLO lo que cambia
ğŸ‘‰ Puede centralizar configuraciones en un â€œsuper POMâ€
ğŸ‘‰ Se vuelve mÃ¡s fÃ¡cil mantener proyectos grandes












'///////////////////
difernecia entre plugins y dependencias 

que son las feses  explica , 


qiue son los goals

Como se solucionan los problemas de dependencias? 
Maven decide una versiÃ³n usando:
nearest-wins
dependency management
path de resoluciÃ³n