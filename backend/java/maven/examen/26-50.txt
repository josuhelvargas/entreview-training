ğŸ”· 26. Â¿Por quÃ© los Integration Tests no deben correr con Surefire?

Porque:

Surefire se ejecuta antes de empaquetar y sin entorno externo preparado.

No soporta lifecycle extendido (pre-integration-test, post-integration-test)

Si un IT falla, Surefire frena el build inmediatamente sin desmontar Docker, BDs, etc.

Failsafe garantiza:

preparaciÃ³n del entorno

ejecuciÃ³n ordenada

limpieza posterior

â¡ï¸ Los IT necesitan un lifecycle propio que Surefire no proporciona.

ğŸ”· 27. Naming conventions de Failsafe para IT

Por defecto detecta:

*IT.java
*ITCase.java
IT*.java


Puedes personalizarlo asÃ­:

<configuration>
  <includes>
    <include>**/*IntegrationTest.java</include>
  </includes>
</configuration>

ğŸ”· 28. Explica el flujo completo de phases cuando usas Failsafe

Order:

pre-integration-test

levantar Docker, crear DB, migraciones

integration-test

Failsafe â†’ failsafe:integration-test

se corren los IT

post-integration-test

se limpian recursos (docker down, borrar tabla, etc.)

verify

Failsafe â†’ failsafe:verify

marca el build como success/failure

genera reports

ğŸ”· 29. Â¿DÃ³nde colocar un test que requiere BD real y en quÃ© phase se ejecuta?

Ruta:
src/integration-test/java/...

Naming convention:
OrderIT.java

EjecuciÃ³n:
Phase â†’ integration-test
via plugin â†’ failsafe:integration-test

ğŸ”· 30. Â¿CÃ³mo levantar y bajar Docker antes/despuÃ©s de los IT?

En el POM:

<execution>
  <id>docker-up</id>
  <phase>pre-integration-test</phase>
  <goals><goal>exec</goal></goals>
  <configuration>
    <executable>docker</executable>
    <arguments>
      <argument>compose</argument>
      <argument>-f</argument>
      <argument>docker-compose.yml</argument>
      <argument>up</argument>
      <argument>-d</argument>
    </arguments>
  </configuration>
</execution>

<execution>
  <id>docker-down</id>
  <phase>post-integration-test</phase>
  <goals><goal>exec</goal></goals>
  <configuration>
    <executable>docker</executable>
    <arguments>
      <argument>compose</argument>
      <argument>-f</argument>
      <argument>docker-compose.yml</argument>
      <argument>down</argument>
    </arguments>
  </configuration>
</execution>

ğŸ”· 31. Â¿QuÃ© hacer si un Integration Test tarda demasiado?

Opciones:

âœ”ï¸ Timeout en Failsafe
<configuration>
  <forkedProcessTimeoutInSeconds>120</forkedProcessTimeoutInSeconds>
</configuration>

âœ”ï¸ Desactivar paralelismo del test que satura recursos
âœ”ï¸ Usar Testcontainers reutilizables
âœ”ï¸ Profiling del test
âœ”ï¸ Separarlos en otro pipeline si son demasiado pesados
ğŸ”· 32. Â¿CÃ³mo evitar que los tests usen accidentalmente configuraciones de producciÃ³n?

Buenas prÃ¡cticas:

Nunca colocar application-prod.yml en src/test/resources

Forzar profile test:

-Dspring.profiles.active=test


En Maven:

<profile>
  <id>test</id>
  <properties>
    <spring.profiles.active>test</spring.profiles.active>
  </properties>
</profile>


Bloquear uso de prod en tests via:

Enforcer rules

Validaciones custom

ğŸ”· 33. Â¿QuÃ© hace spring-boot-starter-parent?

Define versiones compatibles de librerÃ­as

Proporciona default plugin configurations

Gestiona el dependencyManagement

Evita conflictos de versiones

Simplifica el POM drÃ¡sticamente

â¡ï¸ Es un POM padre inteligente.

ğŸ”· 34. Diferencias prÃ¡cticas JAR vs WAR en Spring Boot
Aspecto	JAR	WAR
Tomcat	Embebido	Externo
Despliegue	java -jar	Servidor de apps (Tomcat, WebLogic, WildFly)
Cloud / microservicios	âœ”ï¸ Ideal	âœ–ï¸ No recomendado
Arquitectura	Self-contained	Dependiente de contenedor

Hoy en dÃ­a:
â¡ï¸ JAR es el estÃ¡ndar en microservicios.

ğŸ”· 35. Â¿CÃ³mo relacionar profile Maven con profile Spring Boot?

En el POM:

<profile>
  <id>qa</id>
  <properties>
    <spring.profiles.active>qa</spring.profiles.active>
  </properties>
</profile>


EjecuciÃ³n:

mvn spring-boot:run -Pqa


Spring usa:

application-qa.yml

ğŸ”· 36. Â¿QuÃ© hace el goal spring-boot:repackage?

Transforma un JAR normal en un JAR ejecutable:

incluye dependencias

crea un classloader especial

agrega main manifest

permite:

java -jar app.jar

ğŸ”· 37. Â¿CÃ³mo genera Spring Boot imÃ¡genes Docker sin Dockerfile?

Usa Cloud Native Buildpacks:

mvn spring-boot:build-image


Produce:

paketobuildpacks/builder:base


Ventajas:

reproducible

sin Dockerfile

multistage automÃ¡tico

ğŸ”· 38. Pipeline Jenkins completo (Unit + IT + Package)

Ejemplo:

pipeline {
  agent any
  stages {
    
    stage('Build') {
      steps { sh 'mvn clean verify -Pqa' }
    }

    stage('Package') {
      steps { sh 'mvn package -Prelease' }
    }

    stage('Archive') {
      steps {
        archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
      }
    }

    stage('Deploy Dev') {
      steps { sh 'scp target/app.jar user@dev:/apps/app.jar' }
    }

  }
}

ğŸ”· 39. Workflow en GitHub Actions segÃºn rama
on:
  push:
    branches: [ "dev", "qa", "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build
        run: |
          if [[ $GITHUB_REF == refs/heads/dev ]]; then
            mvn clean verify -Pdev
          elif [[ $GITHUB_REF == refs/heads/qa ]]; then
            mvn clean verify -Pqa
          else
            mvn clean verify -Prelease
          fi

ğŸ”· 40. Â¿CÃ³mo integrar SonarQube al build?

Phase recomendada:
â¡ï¸ verify

POM:

<plugin>
  <groupId>org.sonarsource.scanner.maven</groupId>
  <artifactId>sonar-maven-plugin</artifactId>
  <version>3.9.1.2184</version>
</plugin>


Pipeline:

mvn verify sonar:sonar

ğŸ”· 41. Estrategia para multi-environment deploys

Perfiles Maven: dev, qa, staging, prod

Artefacto Ãºnico â†’ configuraciÃ³n por external config (Spring Config Server)

Pipelines separados:

build (dev)

QA gate

staging regression

production approval

Versionado:

SNAPSHOT â†’ dev

RC â†’ staging

RELEASE â†’ production

ğŸ”· 42. Â¿CÃ³mo firmar artefactos Maven para releases?

Usar el plugin:

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-gpg-plugin</artifactId>
  <version>3.1.0</version>
  <executions>
    <execution>
      <id>sign-artifacts</id>
      <phase>verify</phase>
      <goals><goal>sign</goal></goals>
    </execution>
  </executions>
</plugin>


Requiere:

claves GPG

passphrase

settings.xml cifrado

ğŸ”· 43. Explica el algoritmo nearest-wins

Regla:

Si dos dependencias traen diferentes versiones del mismo artefacto, Maven elige la mÃ¡s cercana al proyecto en el Ã¡rbol de dependencias.

Ejemplo:

app
 â”œâ”€â”€ A:1.0
 â”‚    â””â”€â”€ C:1.0
 â””â”€â”€ B:1.0
      â””â”€â”€ C:2.0


Gana: C:1.0, porque A es mÃ¡s â€œcercaâ€.

ğŸ”· 44. Â¿CÃ³mo crear tu propio plugin Maven?

Pasos:

Crear mÃ³dulo:

<packaging>maven-plugin</packaging>


Crear clase:

@Mojo(name="generate-config", defaultPhase=LifecyclePhase.GENERATE_RESOURCES)
public class GenerateConfigMojo extends AbstractMojo {
    public void execute() { ... }
}


Instalar plugin:

mvn install


Usarlo en otro POM:

<plugin>
  <groupId>com.acme</groupId>
  <artifactId>config-plugin</artifactId>
  <version>1.0.0</version>
  <executions>
    <execution>
      <phase>generate-resources</phase>
      <goals><goal>generate-config</goal></goals>
    </execution>
  </executions>
</plugin>

ğŸ”· 45. Â¿QuÃ© es una "reactor build order inversion"?

Ocurre cuando:

un mÃ³dulo parece depender de otro

pero el Reactor calcula un orden incorrecto

porque una dependencia estÃ¡ marcada como runtime o optional cuando deberÃ­a ser compile

SoluciÃ³n:
â¡ï¸ ajustar scope a compile
â¡ï¸ evitar dependencias circulares
â¡ï¸ usar mvn -X para diagnosticar

ğŸ”· 46. Â¿CÃ³mo construir un BOM corporativo?

Crear un proyecto:

<packaging>pom</packaging>


Con secciÃ³n:

<dependencyManagement>
   <dependencies>
     <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.3.0</version>
     </dependency>
     <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.12</version>
     </dependency>
   </dependencies>
</dependencyManagement>


Luego:

<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.acme.bom</groupId>
      <artifactId>enterprise-bom</artifactId>
      <version>1.0.0</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>

ğŸ”· 47. Â¿CÃ³mo habilitar caching de dependencias en CI/CD?

En GitHub Actions:

- name: Cache Maven repository
  uses: actions/cache@v3
  with:
    path: ~/.m2/repository
    key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}


En Jenkins:

usar agentes persistentes

usar shared library ~/.m2

ğŸ”· 48. Estrategia para SNAPSHOT vs RELEASE

SNAPSHOT

para builds de desarrollo

se publican mÃºltiples versiones en un dÃ­a

nunca usar en producciÃ³n

RELEASE

versiÃ³n fija, inmutable

aprobada vÃ­a pipeline

sirve para reproducibilidad total

Regla:
â¡ï¸ SNAPSHOT para dev
â¡ï¸ RELEASE para QA, staging y prod

ğŸ”· 49. Problemas tÃ­picos con Maven en empresas grandes

Builds lentos por dependencias enormes

Conflictos transitivos

Versiones duplicadas

Falta de BOM corporativo

MÃ³dulos mal ordenados por Reactor

Failsafe mal configurado

Profiles mal usados â†’ builds inconsistentes

Soluciones:

BOM corporativo

Flatten plugin

AnÃ¡lisis de dependencias

Pipelines reproducibles

ğŸ”· 50. Â¿CÃ³mo minimizar tiempos de build en proyectos grandes?

Estrategias reales:

âœ”ï¸ Reactor paralelo
mvn -T 1C clean install

âœ”ï¸ Evitar recompilar mÃ³dulos no cambiados

â†’ usar incremental build (Takari, Maven 4 experimental)

âœ”ï¸ Cache de dependencias en CI/CD
âœ”ï¸ Saltar IT cuando no aplican
-DskipITs

âœ”ï¸ Usar mÃ³dulos mÃ¡s pequeÃ±os (micro-libraries)
âœ”ï¸ Evitar exceso de annotation processors